<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vocal Studio Pro (Upgraded)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        :root {
            --bg: #101010; --surface: #1e1e1e; --panel: #252525;
            --primary: #00d2ff; --secondary: #7b42f6; --accent: #ff0055; --warning: #ffc107;
            --text: #e0e0e0; --text-muted: #888;
            --border-color: #333;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html {
            -webkit-text-size-adjust: 100%;
        }
        body {
            font-family: 'Inter', sans-serif; background-color: var(--bg); color: var(--text);
            display: flex; flex-direction: column; align-items: center; min-height: 100vh;
            padding: 15px;
            overscroll-behavior-y: contain;
        }
        /* Yêu cầu 5: Tối ưu không gian - Bỏ tiêu đề, thu hẹp khoảng cách */
        .main-container {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 15px;
            width: 100%;
            max-width: 1400px;
        }
        .panel { background: var(--panel); border-radius: 15px; padding: 20px; border: 1px solid var(--border-color); margin-bottom: 15px; }
        .panel-title { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; }
        /* Yêu cầu 3: Vùng kích hoạt thu/gọn chỉ là icon */
        .panel-title .toggle-icon { cursor: pointer; padding: 5px; }
        .panel-content { max-height: 1000px; overflow: hidden; transition: max-height 0.5s ease, opacity 0.5s ease, margin-top 0.5s ease; }
        .panel.collapsed .panel-content { max-height: 0; margin-top: -15px !important; opacity: 0; }
        .panel-title .toggle-icon i { transition: transform 0.3s; }
        .panel.collapsed .toggle-icon i { transform: rotate(-90deg); }

        /* Yêu cầu 4: Màn hình giám sát thời gian thực */
        .monitor-screen { background: #000; border-radius: 10px; height: 150px; position: relative; border: 1px solid #444; overflow: hidden; }
        canvas#realtimeVisualizer { width: 100%; height: 100%; display: block; position: absolute; top:0; left:0; z-index: 1; }
        .timer-overlay { position: absolute; top: 10px; right: 15px; font-family: monospace; color: var(--primary); font-size: 1.5rem; z-index: 10; text-shadow: 0 0 5px black; }

        /* Yêu cầu 1: Nút điều khiển chính gộp lại */
        .main-controls { display: flex; justify-content: center; align-items: center; gap: 20px; margin: 20px 0; }
        .btn-big { width: 75px; height: 75px; border-radius: 50%; border: none; font-size: 1.8rem; cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center; box-shadow: 0 10px 20px rgba(0,0,0,0.3); background: var(--primary); color: #000; }
        .btn-big.recording { background: var(--accent); color: white; animation: pulse 1.5s infinite; }
        .btn-small { width: 50px; height: 50px; border-radius: 50%; border: 1px solid #555; background-color: #333; color: #aaa; font-size: 1.2rem; cursor: pointer; }
        .btn-small.active { background-color: var(--warning); color: #000; }

        /* Yêu cầu 3: Cải tiến thanh trượt */
        .fx-panel .panel-title-controls { display: flex; gap: 10px; align-items: center; }
        .slider-group { display: flex; flex-direction: column; gap: 10px; }
        .slider-container { display: flex; align-items: center; gap: 10px; }
        .slider-label { width: 70px; font-size: 0.8rem; color: #aaa; flex-shrink: 0; }
        input[type=range] { flex-grow: 1; accent-color: var(--primary); -webkit-appearance: none; background: #444; height: 4px; border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: white; border-radius: 50%; cursor: pointer; margin-top: -6px; }
        input[type=number].slider-value-input { width: 55px; background: #333; border: 1px solid #555; color: var(--text); border-radius: 5px; padding: 4px; text-align: center; font-size: 0.8rem; }
        /* Khóa thanh trượt */
        .fx-panel:not(.editable) .slider-container input { pointer-events: none; opacity: 0.6; }

        .fx-buttons { display: flex; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
        .fx-btn { flex-grow: 1; background: transparent; color: var(--text-muted); border: none; padding: 10px 5px; cursor: pointer; transition: all 0.2s ease; font-size: 0.8rem; }
        .fx-btn:not(:last-child) { border-right: 1px solid var(--border-color); }
        .fx-btn.active { background: var(--primary); color: #000; font-weight: 600; }
        .fx-panel:not(.editable) .fx-buttons .fx-btn, .fx-panel:not(.editable) .fx-presets-controls button { pointer-events: none; opacity: 0.6; }
        .fx-presets-controls { display: flex; gap: 10px; margin-top: 20px; }
        #fxPresetSelect { flex-grow: 1; background-color: #333; border: 1px solid #555; color: var(--text); padding: 5px; border-radius: 5px; }


        .lyrics-container { position: relative; height: 250px; background: #151515; border-radius: 10px; overflow: hidden; border: 1px solid var(--border-color); }
        #lyricsInput { width: 100%; height: 100%; background: transparent; color: #ddd; border: none; padding: 20px; font-size: 1.1rem; line-height: 1.6; resize: none; outline: none; box-sizing: border-box; }

        /* Yêu cầu 2: Giao diện quản lý dự án */
        #projectList { max-height: 400px; overflow-y: auto; }
        .project-item { background: #2a2a2a; margin-bottom: 10px; border-radius: 8px; border: 1px solid #444; }
        .project-header { padding: 10px 15px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .project-header:hover { background: #333; }
        .project-name { font-weight: bold; }
        .project-recordings { max-height: 0; overflow: hidden; transition: max-height 0.4s ease; padding: 0 15px; }
        .project-item.expanded .project-recordings { max-height: 500px; padding-bottom: 15px; }
        .record-item { padding: 8px 0; border-bottom: 1px solid #3a3a3a; display: flex; align-items: center; gap: 10px; }
        .record-item:last-child { border-bottom: none; }
        .record-item-info { flex-grow: 1; }
        audio.player { height: 30px; width: 150px; }
        .download-btn, .delete-record-btn { color: var(--text-muted); cursor: pointer; padding: 5px; }
        .download-btn:hover, .delete-record-btn:hover { color: var(--primary); }
        .project-header .toggle-icon i { transition: transform 0.3s; }
        .project-item.expanded .project-header .toggle-icon i { transform: rotate(180deg); }

        /* Yêu cầu 7, 8, 9: Giao diện cảnh báo và trạng thái bộ nhớ */
        #storageWarning { display: none; padding: 12px; margin-bottom: 15px; background-color: var(--warning); color: #000; font-weight: bold; border-radius: 8px; text-align: center; }
        #storageStatus { padding: 10px; margin-top: 15px; background: #1a1a1a; border-radius: 8px; font-size: 0.8rem; color: var(--text-muted); text-align: center; }
        #storageStatusBar { width: 100%; background-color: #444; border-radius: 5px; height: 8px; margin-top: 5px; overflow: hidden; }
        #storageStatusBarInner { width: 0%; height: 100%; background-color: var(--secondary); transition: width 0.5s; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; align-items: center; justify-content: center; }
        .modal-content { background: var(--surface); padding: 30px; border-radius: 15px; width: 90%; max-width: 800px; text-align: center; }
        .trim-canvas-container { width: 100%; height: 150px; background: #000; position: relative; margin: 20px 0; border: 1px solid #444; }
        #trimCanvas { position: absolute; top:0; left:0; width:100%; height:100%;}
        .trim-controls { display:flex; flex-wrap: wrap; gap:20px; justify-content:center; }
        .btn-action { background: var(--primary); color: #000; border: none; padding: 12px 30px; border-radius: 8px; font-weight: bold; cursor: pointer; margin: 0 10px; }
        .btn-cancel { background: #444; color: #fff; }

        /* Giao diện modal lưu */
        #saveModal .form-group { margin-bottom: 15px; text-align: left; }
        #saveModal label { display: block; margin-bottom: 5px; font-size: 0.9rem; color: var(--text-muted); }
        #saveModal input, #saveModal select { width: 100%; padding: 10px; background: #333; border: 1px solid #555; color: var(--text); border-radius: 5px; }
        #newProjectName { display: none; margin-top: 10px; }

        .btn-small-icon { background: none; border: 1px solid #555; color: #aaa; width: 35px; height: 35px; border-radius: 8px; cursor: pointer; transition: 0.2s; margin-left: 5px; }
        .btn-small-icon:hover { background: #444; color: white; }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(255, 0, 85, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); }
        }
        /* Yêu cầu 1: Responsive cho mobile */
        @media (max-width: 950px) {
            body { padding: 10px; }
            .main-container { grid-template-columns: 1fr; }
            .trim-controls { flex-direction: column; align-items: center; }
        }
    </style>
</head>
<body>

    <div id="storageWarning"></div>

    <div class="main-container">
        <!-- CỘT TRÁI: ĐIỀU KHIỂN & HÌNH ẢNH -->
        <div>
            <div class="panel">
                <div class="monitor-screen">
                    <canvas id="realtimeVisualizer"></canvas>
                    <div id="timer" class="timer-overlay">00:00:00</div>
                </div>
            </div>

            <div class="main-controls">
                <!-- Yêu cầu 1: Nút ghi/dừng/tạm dừng -->
                <button id="btnRecord" class="btn-big" title="Bắt đầu ghi âm"><i class="fas fa-microphone"></i></button>
                <button id="btnPause" class="btn-small" title="Tạm dừng" style="display: none;"><i class="fas fa-pause"></i></button>
            </div>

            <div class="panel fx-panel">
                <div class="panel-title">
                    <span>Hiệu ứng & EQ</span>
                    <!-- Yêu cầu 3: Nút điều khiển mới -->
                    <div class="panel-title-controls">
                        <button id="btnToggleFxEdit" class="btn-small-icon" title="Mở khóa chỉnh sửa"><i class="fas fa-lock"></i></button>
                        <span class="toggle-icon"><i class="fas fa-chevron-down"></i></span>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="slider-group">
                        <div class="slider-container"><span class="slider-label">Low</span><input type="range" class="fx-slider" data-fx="eq-low" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx-input="eq-low" value="0"></div>
                        <div class="slider-container"><span class="slider-label">Low-Mid</span><input type="range" class="fx-slider" data-fx="eq-lowMid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx-input="eq-lowMid" value="0"></div>
                        <div class="slider-container"><span class="slider-label">Mid</span><input type="range" class="fx-slider" data-fx="eq-mid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx-input="eq-mid" value="0"></div>
                        <div class="slider-container"><span class="slider-label">Hi-Mid</span><input type="range" class="fx-slider" data-fx="eq-highMid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx-input="eq-highMid" value="0"></div>
                        <div class="slider-container"><span class="slider-label">High</span><input type="range" class="fx-slider" data-fx="eq-high" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx-input="eq-high" value="0"></div>
                    </div>
                    <hr style="border-color: #333; margin: 20px 0;">
                    <div class="control-group">
                        <div style="margin-bottom:10px; font-size:0.8rem; color:#aaa;">Reverb (Vang không gian)</div>
                        <div class="fx-buttons">
                            <button class="fx-btn reverb-btn active" data-type="off">Tắt</button>
                            <button class="fx-btn reverb-btn" data-type="studio">Studio</button>
                            <button class="fx-btn reverb-btn" data-type="hall">Hội trường</button>
                        </div>
                        <div class="slider-container" style="margin-top:15px;">
                            <span class="slider-label">Độ lớn</span>
                            <input type="range" id="reverbMix" class="fx-slider" data-fx="reverb-mix" min="0" max="1" step="0.01" value="0.3">
                            <input type="number" class="slider-value-input" data-fx-input="reverb-mix" min="0" max="1" step="0.01" value="0.3">
                        </div>
                    </div>
                     <!-- Yêu cầu 3: Lưu Preset -->
                    <div class="fx-presets-controls">
                        <select id="fxPresetSelect"><option value="">Chọn preset...</option></select>
                        <button id="btnSaveFxPreset" class="btn-small-icon" title="Lưu preset hiện tại"><i class="fas fa-save"></i></button>
                        <button id="btnDeleteFxPreset" class="btn-small-icon" title="Xóa preset đã chọn"><i class="fas fa-trash"></i></button>
                    </div>
                </div>
            </div>
        </div>

        <!-- CỘT PHẢI: LỜI & DỰ ÁN -->
        <div>
            <div class="panel lyrics-panel">
                <div class="panel-title">
                    <span>Lời bài hát (Cho dự án mới)</span>
                    <span class="toggle-icon"><i class="fas fa-chevron-down"></i></span>
                </div>
                <div class="panel-content">
                    <div class="lyrics-container">
                        <textarea id="lyricsInput" placeholder="Dán lời bài hát vào đây để tạo dự án mới..."></textarea>
                    </div>
                </div>
            </div>

            <div class="panel playlist-panel">
                 <div class="panel-title">
                    <span>Thư viện Dự án</span>
                    <span class="toggle-icon"><i class="fas fa-chevron-down"></i></span>
                </div>
                <div class="panel-content">
                    <!-- Yêu cầu 2: Danh sách dự án -->
                    <div id="projectList"></div>
                    <!-- Yêu cầu 7, 8, 9: Trạng thái bộ nhớ -->
                    <div id="storageStatus">
                        <span>Đang tính toán...</span>
                        <div id="storageStatusBar"><div id="storageStatusBarInner"></div></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MODAL CẮT ÂM THANH -->
    <div id="trimModal" class="modal">
        <div class="modal-content">
            <h2 style="color:var(--text)">Chỉnh sửa & Cắt Âm thanh</h2>
            <p style="color:#888; font-size:0.9rem;">Kéo để chọn vùng âm thanh bạn muốn giữ lại.</p>
            <div class="trim-canvas-container"><canvas id="trimCanvas"></canvas></div>
            <div class="trim-controls control-group">
                <div>
                    <span class="slider-label">Bắt đầu: </span><span id="startTimeDisplay">0.0s</span>
                    <input type="range" id="trimStart" value="0" step="0.01" style="max-width:200px; width:100%;">
                </div>
                <div>
                    <span class="slider-label">Kết thúc: </span><span id="endTimeDisplay">0.0s</span>
                    <input type="range" id="trimEnd" value="100" step="0.01" style="max-width:200px; width:100%;">
                </div>
            </div>
            <div style="margin-top:20px;">
                <button id="btnCancelTrim" class="btn-action btn-cancel">Hủy bỏ</button>
                <button id="btnOpenSaveDialog" class="btn-action"><i class="fas fa-save"></i> Lưu bản thu</button>
            </div>
        </div>
    </div>

    <!-- Yêu cầu 2: MODAL LƯU VÀO DỰ ÁN -->
    <div id="saveModal" class="modal">
        <div class="modal-content">
            <h2>Lưu vào Dự án</h2>
            <div class="form-group">
                <label for="recordingName">Tên bản thu (Tùy chỉnh)</label>
                <!-- Yêu cầu 6: Tự động focus -->
                <input type="text" id="recordingName" placeholder="Ví dụ: My Vocal Take 1">
            </div>
            <div class="form-group">
                <label for="projectSelect">Chọn Dự án</label>
                <select id="projectSelect">
                    <option value="new">-- Tạo dự án mới --</option>
                </select>
                <input type="text" id="newProjectName" placeholder="Nhập tên dự án mới...">
            </div>
            <div style="margin-top:20px;">
                <button id="btnCancelSave" class="btn-action btn-cancel">Hủy</button>
                <button id="btnConfirmSave" class="btn-action"><i class="fas fa-check"></i> Xác nhận Lưu</button>
            </div>
        </div>
    </div>

<script>
// --- GLOBAL STATE & DOM ELEMENTS ---
let db;
let audioCtx, micStream, micSource, workletNode, analyser;
let isRecording = false;
let isPaused = false;
let audioBuffer = [];
let fullAudioData;
let sampleRate = 48000;
let timerInterval, startTime, accumulatedTime = 0;
let realtimeVisualizerRafId;

// Yêu cầu 3: Trạng thái hiệu ứng
let fxState = {
    reverb: { type: 'off', mix: 0.3 },
    eq: { low: 0, lowMid: 0, mid: 0, highMid: 0, high: 0 }
};

// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', () => {
    initDB();
    setupEventListeners();
    updateFxControlsFromState();
});

// Yêu cầu 7, 8, 9: Quản lý IndexedDB
async function initDB() {
    const req = indexedDB.open("VocalStudioDB_V3", 3);
    req.onupgradeneeded = e => {
        db = e.target.result;
        if (!db.objectStoreNames.contains('projects')) {
            db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
        }
        if (!db.objectStoreNames.contains('recordings')) {
            const recStore = db.createObjectStore('recordings', { keyPath: 'id', autoIncrement: true });
            recStore.createIndex('projectId', 'projectId', { unique: false });
        }
         if (!db.objectStoreNames.contains('fx_presets')) {
            db.createObjectStore('fx_presets', { keyPath: 'name' });
        }
    };
    req.onsuccess = async e => {
        db = e.target.result;
        await requestPersistentStorage(); // Yêu cầu 7
        await checkStorageQuota(); // Yêu cầu 8
        loadProjects();
        loadFxPresets();
    };
    req.onerror = e => console.error("DB Error:", e.target.errorCode);
}

async function requestPersistentStorage() {
    if (navigator.storage && navigator.storage.persist && navigator.storage.persisted) {
        if (await navigator.storage.persisted()) {
            console.log("Lưu trữ bền vững (Persistent Storage) đã được cấp.");
            return;
        }
        const isPersisted = await navigator.storage.persist();
        if (isPersisted) {
            console.log("Thành công! Trình duyệt đã cấp quyền lưu trữ bền vững.");
        } else {
            console.warn("Trình duyệt không cấp quyền lưu trữ bền vững. Dữ liệu có thể bị xóa.");
            showStorageWarning("Cảnh báo: Dữ liệu của bạn có thể bị trình duyệt xóa nếu ổ đĩa đầy.", true);
        }
    }
}

async function checkStorageQuota(showAlerts = true) {
    if (navigator.storage && navigator.storage.estimate) {
        const { usage, quota } = await navigator.storage.estimate();
        const percentageUsed = (usage / quota) * 100;
        const usageMB = (usage / 1024 / 1024).toFixed(2);
        const quotaMB = (quota / 1024 / 1024).toFixed(2);

        const statusEl = document.getElementById('storageStatus');
        statusEl.innerHTML = `
            <span>Đã dùng: <b>${usageMB} MB</b> / ${quotaMB} MB (${percentageUsed.toFixed(1)}%)</span>
            <div id="storageStatusBar"><div id="storageStatusBarInner" style="width: ${percentageUsed}%;"></div></div>
        `;
        
        if (showAlerts) {
            if (percentageUsed > 95) {
                 showStorageWarning(`Lỗi: Bộ nhớ gần đầy (${percentageUsed.toFixed(1)}%). Không thể lưu bản ghi mới. Hãy tải về và xóa bớt các bản ghi cũ.`);
                 return false; // Critical, block save
            } else if (percentageUsed > 80) {
                 showStorageWarning(`Cảnh báo: Bộ nhớ đã sử dụng ${percentageUsed.toFixed(1)}%. Hãy cân nhắc tải về và xóa bớt các bản ghi cũ.`);
            } else {
                hideStorageWarning();
            }
        }
        return true; // OK to save
    }
    return true; // Can't check, so allow save
}

function showStorageWarning(message, isPersistentWarning = false) {
    const warningEl = document.getElementById('storageWarning');
    warningEl.textContent = message;
    warningEl.style.display = 'block';
    if (!isPersistentWarning) {
        setTimeout(hideStorageWarning, 8000);
    }
}

function hideStorageWarning() {
    document.getElementById('storageWarning').style.display = 'none';
}


function setupEventListeners() {
    // Controls
    document.getElementById('btnRecord').onclick = handleRecordControl;
    document.getElementById('btnPause').onclick = togglePause;

    // Panels
    document.querySelectorAll('.panel-title .toggle-icon').forEach(icon => {
        icon.onclick = () => icon.closest('.panel').classList.toggle('collapsed');
    });

    // FX Controls
    document.getElementById('btnToggleFxEdit').onclick = toggleFxEdit;
    document.querySelectorAll('.fx-slider').forEach(slider => slider.oninput = handleFxSliderInput);
    document.querySelectorAll('.slider-value-input').forEach(input => input.onchange = handleFxValueInput);
    document.querySelectorAll('.reverb-btn').forEach(btn => btn.onclick = handleReverbTypeChange);
    document.getElementById('btnSaveFxPreset').onclick = saveFxPreset;
    document.getElementById('fxPresetSelect').onchange = loadSelectedFxPreset;
    document.getElementById('btnDeleteFxPreset').onclick = deleteSelectedFxPreset;


    // Trimmer
    document.getElementById('btnCancelTrim').onclick = discardRecording;
    document.getElementById('btnOpenSaveDialog').onclick = openSaveDialog;
    document.getElementById('trimStart').oninput = drawTrimWaveform;
    document.getElementById('trimEnd').oninput = drawTrimWaveform;

    // Save Modal
    document.getElementById('btnCancelSave').onclick = () => document.getElementById('saveModal').style.display = 'none';
    document.getElementById('btnConfirmSave').onclick = saveRecordingToProject;
    document.getElementById('projectSelect').onchange = e => {
        document.getElementById('newProjectName').style.display = (e.target.value === 'new') ? 'block' : 'none';
    };

    // Project List
    document.getElementById('projectList').addEventListener('click', handleProjectListClick);
}


// --- AUDIO ENGINE ---
const workletCode = `class RecorderProcessor extends AudioWorkletProcessor { process(inputs) { this.port.postMessage(inputs[0][0]); return true; } } registerProcessor('recorder-processor', RecorderProcessor);`;

async function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
    sampleRate = audioCtx.sampleRate;
    micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, channelCount: 1 }});
    micSource = audioCtx.createMediaStreamSource(micStream);
    buildFXChain(micSource);
    const blob = new Blob([workletCode.toString()], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
    workletNode = new AudioWorkletNode(audioCtx, 'recorder-processor');
    workletNode.port.onmessage = e => {
        if (isRecording && !isPaused && e.data) {
            audioBuffer.push(new Float32Array(e.data));
        }
    };
    analyser.connect(workletNode);
}

// --- RECORDING CONTROLS ---
async function handleRecordControl() {
    const btn = document.getElementById('btnRecord');
    if (isRecording) { // Stop recording
        stopRecording();
        btn.classList.remove('recording');
        btn.title = "Bắt đầu ghi âm";
        btn.innerHTML = `<i class="fas fa-microphone"></i>`;
        document.getElementById('btnPause').style.display = 'none';
    } else { // Start recording
        await initAudio();
        isRecording = true;
        isPaused = false;
        audioBuffer = [];
        accumulatedTime = 0;
        startTimer();
        startRealtimeVisualizer();
        btn.classList.add('recording');
        btn.title = "Dừng ghi âm";
        btn.innerHTML = `<i class="fas fa-stop"></i>`;
        document.getElementById('btnPause').style.display = 'flex';
        document.getElementById('btnPause').classList.remove('active');
    }
}

function togglePause() {
    if (!isRecording) return;
    isPaused = !isPaused;
    const btn = document.getElementById('btnPause');
    if (isPaused) {
        audioCtx.suspend();
        stopTimer();
        btn.classList.add('active');
    } else {
        audioCtx.resume();
        startTimer();
        btn.classList.remove('active');
    }
}

function stopRecording() {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;
    stopTimer();
    stopRealtimeVisualizer();
    micStream.getTracks().forEach(track => track.stop());
    micStream = null;
    if (audioCtx) {
        audioCtx.close().then(() => { audioCtx = null; });
    }
    openTrimmer();
}

// --- TIMER ---
function startTimer() {
    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 100);
}
function stopTimer() {
    accumulatedTime += Date.now() - startTime;
    clearInterval(timerInterval);
}
function updateTimer() {
    const elapsed = accumulatedTime + (Date.now() - startTime);
    const totalSeconds = Math.floor(elapsed / 1000);
    const ms = Math.floor((elapsed % 1000) / 100);
    const s = totalSeconds % 60;
    const m = Math.floor(totalSeconds / 60);
    document.getElementById('timer').innerText = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${ms}`;
}

// Yêu cầu 4: REAL-TIME VISUALIZATION
let visBuffer = new Float32Array(2048); // A small buffer for RMS
let visPos = 0;
function startRealtimeVisualizer() {
    const canvas = document.getElementById('realtimeVisualizer');
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.clientWidth;
    const h = canvas.height = canvas.clientHeight;
    let frameData = new Float32Array(analyser.fftSize);
    let scrollX = 0;
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,w,h);

    function draw() {
        if (!isRecording) return;
        analyser.getFloatTimeDomainData(frameData);
        let sumSquares = 0.0;
        for (const amplitude of frameData) { sumSquares += amplitude * amplitude; }
        const rms = Math.sqrt(sumSquares / frameData.length);
        const barHeight = rms * h * 2.5; // Scale it up
        
        ctx.fillStyle = 'rgba(0, 210, 255, 0.5)';
        ctx.fillRect(scrollX, h/2 - barHeight/2, 2, barHeight);
        
        // Clear the next slice
        ctx.fillStyle = '#000';
        ctx.fillRect(scrollX + 2, 0, 5, h);

        scrollX = (scrollX + 2) % w;
        
        realtimeVisualizerRafId = requestAnimationFrame(draw);
    }
    draw();
}
function stopRealtimeVisualizer() {
    cancelAnimationFrame(realtimeVisualizerRafId);
    const canvas = document.getElementById('realtimeVisualizer');
    const ctx = canvas.getContext('2d');
    setTimeout(() => ctx.clearRect(0, 0, canvas.width, canvas.height), 100);
}


// --- TRIMMER & EDITING ---
function openTrimmer() {
    const modal = document.getElementById('trimModal');
    modal.style.display = 'flex';
    const length = audioBuffer.reduce((sum, chunk) => sum + chunk.length, 0);
    fullAudioData = new Float32Array(length);
    let offset = 0;
    audioBuffer.forEach(chunk => { fullAudioData.set(chunk, offset); offset += chunk.length; });
    const duration = length / sampleRate;
    const sStart = document.getElementById('trimStart');
    const sEnd = document.getElementById('trimEnd');
    sStart.max = duration; sEnd.max = duration;
    sStart.value = 0; sEnd.value = duration;
    drawTrimWaveform();
}
function drawTrimWaveform() {
    const cvs = document.getElementById('trimCanvas');
    const ctx = cvs.getContext('2d');
    const w = cvs.width = cvs.clientWidth;
    const h = cvs.height = cvs.clientHeight;
    ctx.clearRect(0,0,w,h);
    const step = Math.ceil(fullAudioData.length / w);
    const amp = h / 2;
    ctx.strokeStyle = '#555'; ctx.lineWidth = 1; ctx.beginPath();
    for(let i=0; i<w; i++){
        let min = 1.0, max = -1.0;
        for (let j=0; j<step; j++) {
            const val = fullAudioData[(i * step) + j] || 0;
            if (val < min) min = val; if (val > max) max = val;
        }
        ctx.moveTo(i, amp + min * amp); ctx.lineTo(i, amp + max * amp);
    }
    ctx.stroke();
    const sStart = document.getElementById('trimStart');
    const sEnd = document.getElementById('trimEnd');
    const duration = fullAudioData.length / sampleRate;
    const startT = parseFloat(sStart.value);
    const endT = parseFloat(sEnd.value);
    const x1 = (startT / duration) * w;
    const x2 = (endT / duration) * w;
    ctx.fillStyle = 'rgba(0, 210, 255, 0.3)';
    ctx.fillRect(x1, 0, x2 - x1, h);
    document.getElementById('startTimeDisplay').innerText = startT.toFixed(2)+'s';
    document.getElementById('endTimeDisplay').innerText = endT.toFixed(2)+'s';
}
function discardRecording() {
    if(confirm("Hủy bản thu này?")) {
        document.getElementById('trimModal').style.display = 'none';
        audioBuffer = []; fullAudioData = null;
    }
}
function encodeWAV(samples, sampleRate) {
    const buffer = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(buffer);
    const write = (o,s) => { for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); };
    write(0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true);
    write(8, 'WAVE'); write(12, 'fmt '); view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true); view.setUint16(34, 16, true);
    write(36, 'data'); view.setUint32(40, samples.length * 2, true);
    for (let i = 0; i < samples.length; i++) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
    return new Blob([view], { type: 'audio/wav' });
}

// --- PROJECT & SAVING LOGIC (Yêu cầu 2) ---
function openSaveDialog() {
    const modal = document.getElementById('saveModal');
    const select = document.getElementById('projectSelect');
    select.innerHTML = '<option value="new">-- Tạo dự án mới --</option>';

    db.transaction('projects').objectStore('projects').openCursor(null, 'prev').onsuccess = e => {
        const cursor = e.target.result;
        if (cursor) {
            const option = document.createElement('option');
            option.value = cursor.value.id;
            option.textContent = cursor.value.name;
            select.appendChild(option);
            cursor.continue();
        }
    };
    modal.style.display = 'flex';
    document.getElementById('recordingName').focus(); // Yêu cầu 6
}

async function saveRecordingToProject() {
    // Yêu cầu 8: Kiểm tra dung lượng trước khi lưu
    const canSave = await checkStorageQuota();
    if (!canSave) return;
    
    const customName = document.getElementById('recordingName').value.trim() || "Untitled";
    const date = new Date();
    const dateString = `${String(date.getFullYear()).slice(2)}${String(date.getMonth()+1).padStart(2,'0')}${String(date.getDate()).padStart(2,'0')}`;
    const recordingName = `${customName}_${dateString}`; // Yêu cầu 6

    const projectId = document.getElementById('projectSelect').value;
    const lyricsContent = document.getElementById('lyricsInput').value.trim();

    const startT = parseFloat(document.getElementById('trimStart').value);
    const endT = parseFloat(document.getElementById('trimEnd').value);
    const startSample = Math.floor(startT * sampleRate);
    const endSample = Math.floor(endT * sampleRate);
    const slicedData = fullAudioData.slice(startSample, endSample);
    const wavBlob = encodeWAV(slicedData, sampleRate);

    const recordingData = { name: recordingName, blob: wavBlob, date: date };

    if (projectId === 'new') {
        const newProjectName = document.getElementById('newProjectName').value.trim();
        if (!newProjectName) return alert("Vui lòng nhập tên cho dự án mới.");
        if (!lyricsContent) return alert("Dự án mới cần có lời bài hát. Vui lòng nhập lời vào ô bên trái.");

        const projectData = { name: newProjectName, lyrics: lyricsContent };
        const tx = db.transaction(['projects', 'recordings'], 'readwrite');
        const projectStore = tx.objectStore('projects');
        const projectReq = projectStore.add(projectData);
        projectReq.onsuccess = (e) => {
            recordingData.projectId = e.target.result;
            tx.objectStore('recordings').add(recordingData);
        };
        tx.oncomplete = onSaveComplete;

    } else {
        const numProjectId = parseInt(projectId);
        const tx = db.transaction(['projects', 'recordings'], 'readwrite');
        tx.objectStore('projects').get(numProjectId).onsuccess = e => {
            const project = e.target.result;
            if (project.lyrics !== lyricsContent && lyricsContent !== "") {
                if (!confirm("Lời bài hát hiện tại khác với lời trong dự án. Bạn vẫn muốn lưu bản ghi này vào dự án với lời cũ?")) {
                    return;
                }
            }
            recordingData.projectId = numProjectId;
            tx.objectStore('recordings').add(recordingData);
        };
        tx.oncomplete = onSaveComplete;
    }
}

function onSaveComplete() {
    document.getElementById('trimModal').style.display = 'none';
    document.getElementById('saveModal').style.display = 'none';
    loadProjects();
    audioBuffer = []; fullAudioData = null;
    document.getElementById('lyricsInput').value = ''; // Xóa lời sau khi tạo dự án
}

function loadProjects() {
    if(!db) return;
    const list = document.getElementById('projectList');
    list.innerHTML = '';
    const tx = db.transaction(['projects', 'recordings'], 'readonly');
    const projectStore = tx.objectStore('projects');
    const recIndex = tx.objectStore('recordings').index('projectId');

    projectStore.openCursor(null, 'prev').onsuccess = e => {
        const cursor = e.target.result;
        if(cursor) {
            const project = cursor.value;
            const projectItem = document.createElement('div');
            projectItem.className = 'project-item';
            projectItem.dataset.id = project.id;
            projectItem.innerHTML = `
                <div class="project-header" title="Nhấn để xem lời">
                    <span class="project-name">${project.name}</span>
                    <div>
                        <button class="delete-project-btn btn-small-icon" title="Xóa dự án"><i class="fas fa-trash"></i></button>
                        <span class="toggle-icon"><i class="fas fa-chevron-down"></i></span>
                    </div>
                </div>
                <div class="project-recordings"></div>`;
            list.appendChild(projectItem);

            const recContainer = projectItem.querySelector('.project-recordings');
            recIndex.getAll(project.id).onsuccess = e => {
                const recordings = e.target.result;
                if(recordings.length === 0) {
                     recContainer.innerHTML = `<div style="padding:10px 0; color:var(--text-muted); font-style:italic;">Chưa có bản ghi nào.</div>`;
                }
                recordings.sort((a,b) => b.date - a.date).forEach(rec => {
                    const url = URL.createObjectURL(rec.blob);
                    const recDiv = document.createElement('div');
                    recDiv.className = 'record-item';
                    recDiv.innerHTML = `
                        <div class="record-item-info">
                            <div style="font-weight:bold">${rec.name}</div>
                            <div style="font-size:0.8rem; color:#888">${rec.date.toLocaleString('vi-VN')}</div>
                        </div>
                        <audio controls src="${url}" class="player"></audio>
                        <a href="${url}" download="${rec.name.replace(/[^a-z0-9]/gi, '_')}.wav" class="download-btn" title="Tải xuống"><i class="fas fa-download"></i></a>
                        <span class="delete-record-btn" data-id="${rec.id}" title="Xóa bản ghi"><i class="fas fa-times-circle"></i></span>
                    `;
                    recContainer.appendChild(recDiv);
                });
            }
            cursor.continue();
        }
    };
}

function handleProjectListClick(e) {
    const header = e.target.closest('.project-header');
    const deleteProjBtn = e.target.closest('.delete-project-btn');
    const deleteRecBtn = e.target.closest('.delete-record-btn');

    if (deleteProjBtn) {
        const projectItem = deleteProjBtn.closest('.project-item');
        const projectId = parseInt(projectItem.dataset.id);
        const projectName = projectItem.querySelector('.project-name').textContent;
        if (confirm(`Bạn có chắc muốn xóa toàn bộ dự án "${projectName}" và tất cả các bản ghi âm bên trong?`)) {
            deleteProject(projectId);
        }
    } else if (deleteRecBtn) {
        const recId = parseInt(deleteRecBtn.dataset.id);
        if (confirm(`Bạn có chắc muốn xóa bản ghi này?`)) {
            deleteRecording(recId);
        }
    } else if (header) {
        const projectItem = header.closest('.project-item');
        projectItem.classList.toggle('expanded');
        // Load lyrics into textarea on click
        const projectId = parseInt(projectItem.dataset.id);
        db.transaction('projects').objectStore('projects').get(projectId).onsuccess = e => {
            document.getElementById('lyricsInput').value = e.target.result.lyrics;
        }
    }
}

function deleteProject(projectId) {
    const tx = db.transaction(['projects', 'recordings'], 'readwrite');
    const recIndex = tx.objectStore('recordings').index('projectId');
    // Delete all associated recordings
    recIndex.openKeyCursor(IDBKeyRange.only(projectId)).onsuccess = e => {
        const cursor = e.target.result;
        if (cursor) {
            tx.objectStore('recordings').delete(cursor.primaryKey);
            cursor.continue();
        }
    };
    // Delete the project itself
    tx.objectStore('projects').delete(projectId);
    tx.oncomplete = loadProjects;
}
function deleteRecording(recId) {
    const tx = db.transaction('recordings', 'readwrite');
    tx.objectStore('recordings').delete(recId);
    tx.oncomplete = loadProjects;
}


// --- FX & EQ LOGIC (Yêu cầu 3) ---
let eqNodes = [], reverbNode, reverbGain;

function buildFXChain(sourceNode) {
    const freqs = [60, 250, 1000, 4000, 12000];
    let prevNode = sourceNode;
    eqNodes = freqs.map((f, i) => {
        const eq = audioCtx.createBiquadFilter();
        eq.frequency.value = f;
        eq.type = i === 0 ? 'lowshelf' : (i === 4 ? 'highshelf' : 'peaking');
        prevNode.connect(eq);
        prevNode = eq;
        return eq;
    });
    reverbGain = audioCtx.createGain();
    reverbNode = audioCtx.createConvolver();
    prevNode.connect(reverbNode);
    reverbNode.connect(reverbGain);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    const mergePoint = audioCtx.createGain();
    prevNode.connect(mergePoint); // Dry signal
    reverbGain.connect(mergePoint); // Wet signal
    mergePoint.connect(analyser);
    applyAllFxSettings();
}

function applyAllFxSettings() {
    if (!audioCtx) return;
    eqNodes[0].gain.value = fxState.eq.low;
    eqNodes[1].gain.value = fxState.eq.lowMid;
    eqNodes[2].gain.value = fxState.eq.mid;
    eqNodes[3].gain.value = fxState.eq.highMid;
    eqNodes[4].gain.value = fxState.eq.high;
    if (fxState.reverb.type === 'off') {
        reverbGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
    } else {
        setReverbImpulse(fxState.reverb.type);
        reverbGain.gain.setTargetAtTime(fxState.reverb.mix, audioCtx.currentTime, 0.01);
    }
}

function setReverbImpulse(type) {
    if (!audioCtx || !reverbNode) return;
    const duration = type === 'hall' ? 2.0 : (type === 'studio' ? 0.8 : 0.01);
    const decay = type === 'hall' ? 2.5 : 4.0;
    const length = sampleRate * duration;
    const impulse = audioCtx.createBuffer(2, length, sampleRate);
    for (let c = 0; c < 2; c++) {
        const data = impulse.getChannelData(c);
        for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
    }
    reverbNode.buffer = impulse;
}

function toggleFxEdit() {
    const panel = document.querySelector('.fx-panel');
    const btn = document.getElementById('btnToggleFxEdit');
    panel.classList.toggle('editable');
    if (panel.classList.contains('editable')) {
        btn.innerHTML = `<i class="fas fa-lock-open"></i>`;
        btn.title = "Khóa chỉnh sửa";
    } else {
        btn.innerHTML = `<i class="fas fa-lock"></i>`;
        btn.title = "Mở khóa chỉnh sửa";
    }
}
function handleFxSliderInput(e) {
    const value = parseFloat(e.target.value);
    const fxType = e.target.dataset.fx;
    document.querySelector(`.slider-value-input[data-fx-input="${fxType}"]`).value = value;
    updateFxState(fxType, value);
}
function handleFxValueInput(e) {
    const value = parseFloat(e.target.value);
    const fxType = e.target.dataset.fxInput;
    document.querySelector(`.fx-slider[data-fx="${fxType}"]`).value = value;
    updateFxState(fxType, value);
}
function handleReverbTypeChange(e) {
    const type = e.target.dataset.type;
    document.querySelectorAll('.reverb-btn').forEach(b => b.classList.remove('active'));
    e.target.classList.add('active');
    updateFxState('reverb-type', type);
}
function updateFxState(type, value) {
    if (type.startsWith('eq-')) {
        fxState.eq[type.replace('eq-','')] = value;
    } else if (type === 'reverb-mix') {
        fxState.reverb.mix = value;
    } else if (type === 'reverb-type') {
        fxState.reverb.type = value;
    }
    if (audioCtx) applyAllFxSettings();
}
function updateFxControlsFromState() {
    Object.keys(fxState.eq).forEach(key => {
        document.querySelector(`[data-fx="eq-${key}"]`).value = fxState.eq[key];
        document.querySelector(`[data-fx-input="eq-${key}"]`).value = fxState.eq[key];
    });
    document.querySelector('[data-fx="reverb-mix"]').value = fxState.reverb.mix;
    document.querySelector('[data-fx-input="reverb-mix"]').value = fxState.reverb.mix;
    document.querySelectorAll('.reverb-btn').forEach(b => b.classList.remove('active'));
    document.querySelector(`.reverb-btn[data-type="${fxState.reverb.type}"]`).classList.add('active');
}
function saveFxPreset() {
    const name = prompt("Đặt tên cho preset hiệu ứng này:");
    if (!name || !name.trim()) return;
    const preset = { name: name.trim(), settings: JSON.parse(JSON.stringify(fxState)) };
    const tx = db.transaction('fx_presets', 'readwrite');
    tx.objectStore('fx_presets').put(preset);
    tx.oncomplete = () => {
        alert('Đã lưu preset!');
        loadFxPresets();
    };
}
function loadFxPresets() {
    const select = document.getElementById('fxPresetSelect');
    select.innerHTML = '<option value="">Chọn preset...</option>';
    db.transaction('fx_presets').objectStore('fx_presets').openCursor().onsuccess = e => {
        const cursor = e.target.result;
        if (cursor) {
            select.add(new Option(cursor.value.name, cursor.value.name));
            cursor.continue();
        }
    };
}
function loadSelectedFxPreset(e) {
    const name = e.target.value;
    if (!name) return;
    db.transaction('fx_presets').objectStore('fx_presets').get(name).onsuccess = e => {
        if(e.target.result) {
            fxState = e.target.result.settings;
            updateFxControlsFromState();
            if (audioCtx) applyAllFxSettings();
        }
    };
}
function deleteSelectedFxPreset() {
    const name = document.getElementById('fxPresetSelect').value;
    if (!name) return alert("Vui lòng chọn một preset để xóa.");
    if (confirm(`Bạn có chắc muốn xóa preset "${name}"?`)) {
        const tx = db.transaction('fx_presets', 'readwrite');
        tx.objectStore('fx_presets').delete(name);
        tx.oncomplete = loadFxPresets;
    }
}
</script>
</body>
</html>