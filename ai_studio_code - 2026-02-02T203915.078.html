<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vocal Studio Pro (Upgraded)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
    :root {
        --bg: #101010; --surface: #1e1e1e; --panel: #252525;
        --primary: #00d2ff; --secondary: #7b42f6; --accent: #ff0055; --warning: #ffc107;
        --text: #e0e0e0; --text-muted: #888;
        --border-color: #333;
    }
    /* Yêu cầu 1: Sửa lỗi tràn viền và tối ưu global */
    * {
        box-sizing: border-box;
    }
    body {
        font-family: 'Inter', sans-serif; background-color: var(--bg); color: var(--text);
        margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh;
        padding: 15px; /* Thêm padding để nội dung không dính sát viền */
    }
    /* Yêu cầu 5: Bỏ tiêu đề, tối ưu không gian */
    .main-container {
        display: grid;
        grid-template-columns: 1fr 380px;
        gap: 15px;
        width: 100%;
        max-width: 1300px;
    }
    .panel { background: var(--panel); border-radius: 15px; padding: 20px; border: 1px solid var(--border-color); margin-bottom: 15px; }
    .panel-title { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; }
    /* Yêu cầu 3: Chỉ icon mới có chức năng cuộn */
    .panel-title .toggle-icon { cursor: pointer; transition: transform 0.3s; padding: 5px; }
    .panel-content { max-height: 1000px; overflow: hidden; transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out; }
    .panel.collapsed .panel-content { max-height: 0; margin-top: -15px !important; }
    .panel.collapsed .toggle-icon { transform: rotate(-90deg); }

    /* Yêu cầu 4: Màn hình giám sát thời gian thực */
    .monitor-screen { background: #000; border-radius: 10px; height: 120px; position: relative; border: 1px solid #444; overflow: hidden; display: flex; align-items: center; justify-content: center; }
    canvas#visualizer { width: 100%; height: 100%; display: block; position: absolute; top:0; left:0; z-index: 1; }
    /* Biểu đồ âm lượng thời gian thực (mới) */
    canvas#realtimeWaveformCanvas { width: 100%; height: 100%; position: absolute; top:0; left:0; z-index: 2; }

    .timer-overlay { position: absolute; bottom: 10px; right: 15px; font-family: monospace; color: var(--primary); font-size: 1.2rem; z-index: 10; background: rgba(0,0,0,0.5); padding: 2px 8px; border-radius: 5px;}

    /* Yêu cầu 3: Giao diện thanh trượt được cải tiến */
    .control-group { margin-bottom: 15px; }
    .slider-container { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
    .slider-label { width: 80px; font-size: 0.8rem; color: #aaa; flex-shrink: 0; }
    input[type=range] { flex-grow: 1; accent-color: var(--primary); height: 4px; background: #444; border-radius: 2px; -webkit-appearance: none; min-width: 50px; transition: opacity 0.2s; }
    input[type=range].locked { opacity: 0.5; pointer-events: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 15px; height: 15px; background: white; border-radius: 50%; cursor: pointer; }
    input[type=number].slider-value-input { width: 60px; background: #333; border: 1px solid #555; color: var(--text); border-radius: 5px; padding: 4px; text-align: center; }
    input[type=number].slider-value-input.locked { background: #222; color: #777; pointer-events: none; }
    .fx-toolbar { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-bottom: 15px; }
    #fxPresetSelect { background: #333; border: 1px solid #555; color: var(--text); border-radius: 5px; padding: 5px; }
    .btn-action { background: var(--primary); color: #000; border: none; padding: 5px 12px; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 0.8rem; }
    .btn-action.locked { background: var(--secondary); }

    /* Yêu cầu 1: Nút điều khiển chính mới */
    .main-controls { display: flex; justify-content: center; align-items: center; gap: 20px; margin: 20px 0; }
    .btn-main-action { width: 70px; height: 70px; border-radius: 50%; border: none; font-size: 1.8rem; cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center; color: white; }
    #btnRecordControl.idle { background: var(--primary); }
    #btnRecordControl.recording { background: var(--accent); animation: pulse 1.5s infinite; }
    #btnRecordControl.paused { background: var(--warning); }
    #btnPause { font-size: 1.5rem; background-color: #444; }
    #btnPause.paused { color: var(--warning); }

    .fx-buttons { display: flex; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
    .fx-btn { flex-grow: 1; background: transparent; color: var(--text-muted); border: none; padding: 10px 5px; cursor: pointer; transition: all 0.2s ease; font-size: 0.8rem; }
    .fx-btn:not(:last-child) { border-right: 1px solid var(--border-color); }
    .fx-btn.active { background: var(--primary); color: #000; font-weight: 600; }

    .lyrics-panel-header { display: flex; justify-content: flex-end; align-items: center; margin-bottom: 15px; }
    #lyrics-playlist { max-height: 150px; overflow-y: auto; margin-bottom: 15px; background: #1a1a1a; border-radius: 8px; padding: 5px; border: 1px solid var(--border-color); }
    .lyric-item { padding: 10px; border-radius: 5px; cursor: pointer; margin-bottom: 5px; border: 1px solid transparent; transition: all 0.2s; font-size: 0.9rem; }
    .lyric-item.selected { background-color: #303f5a; border-color: var(--primary); font-weight: 600; }
    .lyrics-container { position: relative; height: 300px; background: #151515; border-radius: 10px; overflow: hidden; border: 1px solid var(--border-color); }
    #lyricsInput { width: 100%; height: 100%; background: transparent; color: #ddd; border: none; padding: 20px; font-size: 1.1rem; line-height: 1.6; resize: none; outline: none; box-sizing: border-box; font-family: 'Inter', sans-serif; }
    .scroll-controls { position: absolute; bottom: 10px; right: 10px; display: flex; gap: 5px; background: rgba(0,0,0,0.6); padding: 5px; border-radius: 20px; align-items: center; }

    /* Yêu cầu 2: Giao diện thư viện dự án */
    .project-item { background: #2a2a2a; border-radius: 8px; margin-bottom: 10px; border: 1px solid #444; }
    .project-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; cursor: pointer; }
    .project-title { font-weight: bold; }
    .project-recordings { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out; padding: 0 15px; }
    .project-item.open .project-recordings { max-height: 500px; padding-bottom: 15px; }
    .record-item { padding: 8px 0; display: flex; align-items: center; gap: 10px; border-bottom: 1px solid #333; }
    .record-item:last-child { border-bottom: none; }
    .record-item-info { flex-grow: 1; }

    /* Yêu cầu 7,8: Giao diện cảnh báo và trạng thái bộ nhớ */
    #storage-warning { display: none; background: var(--warning); color: #000; padding: 10px; text-align: center; font-weight: 600; border-radius: 8px; margin-bottom: 15px; }
    #storageStatus { font-size: 0.8rem; color: var(--text-muted); margin-top: 15px; text-align: center; }

    /* Modal chung */
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
    .modal-content { background: var(--surface); padding: 30px; border-radius: 15px; width: 90%; max-width: 800px; text-align: center; border: 1px solid var(--border-color); }
    .modal-content h2 { margin-top: 0; color: var(--primary); }
    .modal-content p { color: var(--text-muted); }
    .btn-save { background: var(--primary); color: #000; }
    .btn-cancel { background: #444; color: #fff; }
    .modal-button { border: none; padding: 10px 30px; border-radius: 5px; font-weight: bold; cursor: pointer; margin: 0 10px; }
    
    /* Yêu cầu 6: Input trong modal */
    .modal-input { width: 100%; padding: 10px; background: #111; border: 1px solid #444; color: var(--text); border-radius: 5px; font-size: 1rem; margin: 20px 0; }

    .trim-canvas-container { width: 100%; height: 150px; background: #000; position: relative; margin: 20px 0; border: 1px solid #444; }
    #trimCanvas { position: absolute; top:0; left:0; width:100%; height:100%;}
    #volumeWaveformCanvas { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; }
    .trim-controls { display:flex; flex-wrap: wrap; gap:20px; justify-content:center; }

    @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.4); } 70% { box-shadow: 0 0 0 20px rgba(255, 0, 85, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); } }
    
    /* Yêu cầu 1: Responsive cho di động */
    @media (max-width: 900px) {
        body { padding: 10px; }
        .main-container { grid-template-columns: 1fr; }
        .trim-controls { flex-direction: column; align-items: center; }
    }
</style>
</head>
<body>

<!-- Yêu cầu 7,8: Vùng cảnh báo bộ nhớ -->
<div id="storage-warning"></div>

<div class="main-container">
    <!-- CỘT TRÁI: ĐIỀU KHIỂN & HÌNH ẢNH -->
    <div>
        <div class="panel">
            <div class="monitor-screen">
                <!-- Yêu cầu 4: Đã đổi tên canvas để rõ ràng hơn -->
                <canvas id="realtimeWaveformCanvas"></canvas>
                <div id="timer" class="timer-overlay">00:00</div>
            </div>
        </div>

        <!-- Yêu cầu 1: Cụm nút điều khiển mới -->
        <div class="main-controls">
            <button id="btnRecordControl" class="btn-main-action idle" title="Ghi âm"><i class="fas fa-microphone"></i></button>
            <button id="btnPause" class="btn-main-action" title="Tạm dừng" style="display: none;"><i class="fas fa-pause"></i></button>
        </div>

        <div class="panel fx-panel">
            <div class="panel-title">
                <span>Hiệu ứng & EQ</span>
                <i class="fas fa-sliders-h toggle-icon"></i>
            </div>
            <div class="panel-content">
                <!-- Yêu cầu 3: Thanh công cụ cho FX Presets và nút khóa -->
                <div class="fx-toolbar">
                    <select id="fxPresetSelect">
                        <option value="">Chọn cấu hình...</option>
                    </select>
                    <div>
                        <button id="btnSavePreset" class="btn-action">Lưu</button>
                        <button id="btnEditFX" class="btn-action locked">Chỉnh sửa</button>
                    </div>
                </div>

                <div class="control-group">
                    <div class="slider-container"><span class="slider-label">Low</span><input type="range" class="fx-slider" data-fx="eq-low" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx="eq-low" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Low-Mid</span><input type="range" class="fx-slider" data-fx="eq-lowMid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx="eq-lowMid" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Mid</span><input type="range" class="fx-slider" data-fx="eq-mid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx="eq-mid" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Hi-Mid</span><input type="range" class="fx-slider" data-fx="eq-highMid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx="eq-highMid" value="0"></div>
                    <div class="slider-container"><span class="slider-label">High</span><input type="range" class="fx-slider" data-fx="eq-high" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-fx="eq-high" value="0"></div>
                </div>
                <div class="control-group">
                    <div class="fx-buttons">
                        <button class="fx-btn reverb-btn active" data-type="off">Tắt Reverb</button>
                        <button class="fx-btn reverb-btn" data-type="studio">Studio</button>
                        <button class="fx-btn reverb-btn" data-type="hall">Hội trường</button>
                    </div>
                    <div class="slider-container" style="margin-top:15px;">
                        <span class="slider-label">Độ lớn</span>
                        <input type="range" id="reverbMix" class="fx-slider" data-fx="reverb-mix" min="0" max="1" step="0.05" value="0.3">
                        <input type="number" class="slider-value-input" data-fx="reverb-mix" value="0.3" min="0" max="1" step="0.05">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CỘT PHẢI: LỜI BÀI HÁT & THƯ VIỆN -->
    <div>
        <div class="panel lyrics-panel">
            <div class="panel-title">
                <span>Lời bài hát</span>
                <i class="fas fa-music toggle-icon"></i>
            </div>
            <div class="panel-content">
                <div id="lyrics-playlist"></div>
                <div class="lyrics-panel-header">
                    <button id="btnSaveLyrics" class="btn-small-icon" title="Lưu lời mới"><i class="fas fa-save"></i></button>
                    <button id="btnDeleteLyrics" class="btn-small-icon" title="Xóa lời đang chọn"><i class="fas fa-trash-alt"></i></button>
                </div>
                <div class="lyrics-container">
                    <textarea id="lyricsInput" placeholder="Dán lời bài hát vào đây..."></textarea>
                    <div class="scroll-controls">
                        <i class="fas fa-tachometer-alt" style="color:#aaa; font-size:0.8rem; padding-left:5px;"></i>
                        <input type="range" id="scrollSpeed" min="0" max="5" step="1" value="1" title="Tốc độ cuộn" style="width:60px;">
                    </div>
                </div>
            </div>
        </div>

        <div class="panel playlist-panel">
            <div class="panel-title">
                <span>Thư viện Dự án</span>
                <i class="fas fa-list-ul toggle-icon"></i>
            </div>
            <div class="panel-content">
                <div id="project-list"></div>
                <!-- Yêu cầu 7,8: Hiển thị trạng thái bộ nhớ -->
                <div id="storageStatus"></div>
            </div>
        </div>
    </div>
</div>

<!-- MODAL CẮT ÂM THANH -->
<div id="trimModal" class="modal">
    <div class="modal-content">
        <h2>Chỉnh sửa & Cắt Âm thanh</h2>
        <p>Kéo để chọn vùng âm thanh bạn muốn giữ lại.</p>
        <div class="trim-canvas-container">
            <canvas id="trimCanvas"></canvas>
            <!-- Yêu cầu 4: Canvas riêng cho biểu đồ âm lượng tổng -->
            <canvas id="volumeWaveformCanvas"></canvas>
        </div>
        <div class="trim-controls control-group">
            <div><span class="slider-label">Bắt đầu: </span><span id="startTimeDisplay">0.0s</span><input type="range" id="trimStart" value="0" step="0.01"></div>
            <div><span class="slider-label">Kết thúc: </span><span id="endTimeDisplay">0.0s</span><input type="range" id="trimEnd" value="100" step="0.01"></div>
        </div>
        <div style="margin-top:20px;">
            <button id="btnCancelTrim" class="modal-button btn-cancel">Hủy bỏ</button>
            <!-- Yêu cầu 2: Nút này sẽ mở modal dự án -->
            <button id="btnProceedToSave" class="modal-button btn-save"><i class="fas fa-project-diagram"></i> Lưu vào Dự án</button>
        </div>
    </div>
</div>

<!-- Yêu cầu 2: MODAL CHỌN/TẠO DỰ ÁN (Mới) -->
<div id="projectModal" class="modal">
    <div class="modal-content">
        <h2>Chọn hoặc Tạo Dự án</h2>
        <p>Lưu bản ghi này vào một dự án hiện có hoặc tạo một dự án mới.</p>
        <div id="existing-projects-list" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 20px;"></div>
        <input type="text" id="newProjectName" class="modal-input" placeholder="...hoặc nhập tên dự án mới">
        <div style="margin-top:20px;">
            <button id="btnCancelProject" class="modal-button btn-cancel">Hủy</button>
            <button id="btnSelectProject" class="modal-button btn-save">Tiếp tục</button>
        </div>
    </div>
</div>

<!-- Yêu cầu 6: MODAL ĐẶT TÊN FILE (Mới) -->
<div id="saveModal" class="modal">
    <div class="modal-content">
        <h2>Đặt tên cho Bản thu</h2>
        <p>Tên file cuối cùng sẽ có dạng: <span id="fileNamePreview"></span></p>
        <input type="text" id="recordingNameInput" class="modal-input" placeholder="Ví dụ: Verse 1 - Take 2">
        <div style="margin-top:20px;">
            <button id="btnCancelSave" class="modal-button btn-cancel">Hủy</button>
            <button id="btnConfirmSave" class="modal-button btn-save"><i class="fas fa-save"></i> Lưu</button>
        </div>
    </div>
</div>


<script>
// --- GLOBAL STATE & DOM ELEMENTS ---
let db;
let audioCtx, micStream, micSource, workletNode, analyser;
let recordingState = 'idle'; // idle, recording, paused
let audioBuffer = [];
let fullAudioData;
let sampleRate = 48000;
let timerInterval, startTime, pausedTime = 0;
let lyricsScrollInterval;
let isFxSlidersLocked = true; // Yêu cầu 3: Mặc định khóa
let tempRecordingData = {}; // Lưu dữ liệu tạm thời giữa các modal

// Yêu cầu 3: Trạng thái hiệu ứng mặc định
let fxState = {
    reverb: { type: 'off', mix: 0.3 },
    eq: { low: 0, lowMid: 0, mid: 0, highMid: 0, high: 0 }
};

// --- Yêu cầu 4: Biến cho canvas thời gian thực ---
let realtimeWaveformCtx, realtimeWaveformBuffer = [], realtimeWaveformPos = 0;


// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', () => {
    initDB();
    setupEventListeners();
    toggleFxSlidersLock(true); // Khóa thanh trượt khi tải trang
});

// Yêu cầu 7,8: Cập nhật DB và khởi tạo các chức năng mới
function initDB() {
    const req = indexedDB.open("VocalStudioDB_V3", 3); // Tăng version để nâng cấp
    req.onupgradeneeded = e => {
        db = e.target.result;
        if (!db.objectStoreNames.contains('projects')) {
            db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
        }
        if (!db.objectStoreNames.contains('recs')) {
            const recStore = db.createObjectStore('recs', { keyPath: 'id', autoIncrement: true });
            recStore.createIndex('projectId', 'projectId', { unique: false }); // Index để truy vấn bản ghi theo dự án
        }
        if (!db.objectStoreNames.contains('lyrics')) {
            db.createObjectStore('lyrics', { keyPath: 'id', autoIncrement: true });
        }
        if (!db.objectStoreNames.contains('fxPresets')) { // Yêu cầu 3
            db.createObjectStore('fxPresets', { keyPath: 'id', autoIncrement: true });
        }
    };
    req.onsuccess = e => {
        db = e.target.result;
        loadProjectsAndRecordings();
        loadLyricsLibrary();
        loadFxPresets(); // Yêu cầu 3
        requestPersistentStorage(); // Yêu cầu 7
        checkStorageQuota(); // Yêu cầu 8
    };
    req.onerror = e => console.error("DB Error:", e.target.errorCode);
}

// Yêu cầu 7: Triển khai Lưu trữ Bền vững
async function requestPersistentStorage() {
    if (navigator.storage && navigator.storage.persist && navigator.storage.persisted) {
        let isPersisted = await navigator.storage.persisted();
        if (!isPersisted) {
            isPersisted = await navigator.storage.persist();
        }
        console.log(`Storage is ${isPersisted ? 'persistent' : 'not persistent'}.`);
        if (!isPersisted) {
            // Có thể hiện một thông báo nhỏ ở đây
        }
    }
}

// Yêu cầu 8: Theo dõi và Cảnh báo Dung lượng
async function checkStorageQuota(showWarning = true) {
    if (navigator.storage && navigator.storage.estimate) {
        const { usage, quota } = await navigator.storage.estimate();
        const usageMB = (usage / 1024 / 1024).toFixed(2);
        const quotaMB = (quota / 1024 / 1024).toFixed(2);
        const percentageUsed = (usage / quota) * 100;

        const statusEl = document.getElementById('storageStatus');
        if(statusEl) statusEl.innerHTML = `Lưu trữ: <b>${usageMB} MB / ${quotaMB} MB</b> (${percentageUsed.toFixed(1)}%)`;

        const warningEl = document.getElementById('storage-warning');
        if (showWarning && percentageUsed > 80) {
            warningEl.style.display = 'block';
            warningEl.innerHTML = `Cảnh báo: Bộ nhớ đã sử dụng ${percentageUsed.toFixed(0)}% (${usageMB} MB / ${quotaMB} MB). Hãy tải xuống các bản ghi cũ để tránh lỗi.`;
        } else {
            warningEl.style.display = 'none';
        }
        return { usage, quota, percentageUsed };
    }
    return { usage: 0, quota: Infinity, percentageUsed: 0 };
}


// --- EVENT LISTENERS ---
function setupEventListeners() {
    document.getElementById('btnRecordControl').onclick = handleRecordControl;
    document.getElementById('btnPause').onclick = handlePause;

    // Yêu cầu 3: Chỉ icon mới toggle panel
    document.querySelectorAll('.toggle-icon').forEach(icon => {
        icon.onclick = (e) => {
            e.stopPropagation();
            icon.closest('.panel').classList.toggle('collapsed');
        };
    });

    // ... Event Listeners cho các thành phần khác ...
    document.querySelectorAll('.reverb-btn').forEach(btn => {
        btn.onclick = () => {
            if (isFxSlidersLocked) return;
            fxState.reverb.type = btn.dataset.type;
            document.querySelectorAll('.reverb-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            applyReverbSettings();
        };
    });

    document.querySelectorAll('.fx-slider, .slider-value-input').forEach(input => {
        input.oninput = e => {
            const type = e.target.dataset.fx.split('-')[0];
            const param = e.target.dataset.fx.split('-')[1];
            let value = (type === 'reverb') ? parseFloat(e.target.value) : parseInt(e.target.value);
            
            if (type === 'eq') fxState.eq[param] = value;
            else if (type === 'reverb') fxState.reverb.mix = value;
            
            // Sync slider and number input
            document.querySelector(`.fx-slider[data-fx="${e.target.dataset.fx}"]`).value = value;
            document.querySelector(`.slider-value-input[data-fx="${e.target.dataset.fx}"]`).value = value;

            if(type === 'eq') applyEQSettings();
            else applyReverbSettings();
        };
    });
    
    document.getElementById('btnEditFX').onclick = () => toggleFxSlidersLock(!isFxSlidersLocked);
    document.getElementById('btnSavePreset').onclick = saveFxPreset;
    document.getElementById('fxPresetSelect').onchange = (e) => loadSelectedFxPreset(e.target.value);

    // Lyrics
    document.getElementById('btnSaveLyrics').onclick = saveLyrics;
    document.getElementById('btnDeleteLyrics').onclick = deleteCurrentLyrics;
    document.getElementById('lyrics-playlist').addEventListener('click', (e) => {
        const item = e.target.closest('.lyric-item');
        if (item) loadSelectedLyrics(parseInt(item.dataset.id));
    });

    // Modals
    document.getElementById('btnCancelTrim').onclick = discardRecording;
    document.getElementById('btnProceedToSave').onclick = showProjectModal;
    document.getElementById('trimStart').oninput = drawTrimWaveform;
    document.getElementById('trimEnd').oninput = drawTrimWaveform;

    document.getElementById('btnCancelProject').onclick = () => document.getElementById('projectModal').style.display = 'none';
    document.getElementById('btnSelectProject').onclick = handleProjectSelection;

    document.getElementById('btnCancelSave').onclick = () => document.getElementById('saveModal').style.display = 'none';
    document.getElementById('btnConfirmSave').onclick = saveTrimmedAudio;
    document.getElementById('recordingNameInput').onkeyup = updateFileNamePreview;
}

// --- AUDIO ENGINE ---
const workletCode = `class RecorderProcessor extends AudioWorkletProcessor { process(inputs) { this.port.postMessage(inputs[0][0]); return true; } } registerProcessor('recorder-processor', RecorderProcessor);`;

async function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
    sampleRate = audioCtx.sampleRate;
    micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, channelCount: 1 }});
    micSource = audioCtx.createMediaStreamSource(micStream);
    buildFXChain(micSource);
    const blob = new Blob([workletCode.toString()], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
    workletNode = new AudioWorkletNode(audioCtx, 'recorder-processor');
    workletNode.port.onmessage = (event) => {
        if (recordingState === 'recording' && event.data) {
            audioBuffer.push(new Float32Array(event.data));
            updateRealtimeWaveform(event.data);
        }
    };
    analyser.connect(workletNode);
    workletNode.connect(audioCtx.destination);
}

// --- RECORDING CONTROLS (Yêu cầu 1) ---
async function handleRecordControl() {
    if (recordingState === 'idle') { // Start Recording
        await initAudio();
        recordingState = 'recording';
        audioBuffer = [];
        pausedTime = 0;
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
        updateRecordButtonUI();
        startLyricsScroll();
        startRealtimeWaveform();
    } else { // Stop Recording
        stopRecording();
    }
}

function handlePause() {
    if (recordingState === 'recording') {
        recordingState = 'paused';
        audioCtx.suspend();
        pausedTime += Date.now() - startTime;
        clearInterval(timerInterval);
        stopLyricsScroll();
    } else if (recordingState === 'paused') {
        recordingState = 'recording';
        audioCtx.resume();
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
        startLyricsScroll();
    }
    updateRecordButtonUI();
}

function stopRecording() {
    if (recordingState === 'idle') return;
    
    recordingState = 'idle';
    clearInterval(timerInterval);
    updateRecordButtonUI();
    stopLyricsScroll();

    micStream.getTracks().forEach(track => track.stop());
    micStream = null;
    if (audioCtx) {
        audioCtx.close().then(() => { audioCtx = null; });
    }
    openTrimmer();
}

function updateRecordButtonUI() {
    const btn = document.getElementById('btnRecordControl');
    const pauseBtn = document.getElementById('btnPause');
    const icon = btn.querySelector('i');

    btn.classList.remove('idle', 'recording', 'paused');
    pauseBtn.classList.remove('paused');

    switch (recordingState) {
        case 'idle':
            btn.classList.add('idle');
            icon.className = 'fas fa-microphone';
            btn.title = 'Ghi âm';
            pauseBtn.style.display = 'none';
            document.getElementById('timer').innerText = '00:00';
            break;
        case 'recording':
            btn.classList.add('recording');
            icon.className = 'fas fa-stop';
            btn.title = 'Dừng';
            pauseBtn.style.display = 'flex';
            break;
        case 'paused':
            btn.classList.add('paused');
            icon.className = 'fas fa-stop';
            btn.title = 'Dừng';
            pauseBtn.style.display = 'flex';
            pauseBtn.classList.add('paused');
            break;
    }
}

function updateTimer() {
    const elapsed = pausedTime + (Date.now() - startTime);
    const diff = Math.floor(elapsed / 1000);
    const m = Math.floor(diff/60).toString().padStart(2,'0');
    const s = (diff%60).toString().padStart(2,'0');
    document.getElementById('timer').innerText = `${m}:${s}`;
}

// --- VISUALIZATION (Yêu cầu 4) ---
function startRealtimeWaveform() {
    const canvas = document.getElementById('realtimeWaveformCanvas');
    realtimeWaveformCtx = canvas.getContext('2d');
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    realtimeWaveformBuffer = new Float32Array(canvas.width);
    realtimeWaveformPos = 0;
    drawRealtimeWaveform();
}

function updateRealtimeWaveform(dataChunk) {
    // Lấy giá trị đỉnh của chunk để vẽ
    let peak = 0;
    for (let i = 0; i < dataChunk.length; i++) {
        if (Math.abs(dataChunk[i]) > peak) {
            peak = Math.abs(dataChunk[i]);
        }
    }
    realtimeWaveformBuffer[realtimeWaveformPos] = peak;
    realtimeWaveformPos = (realtimeWaveformPos + 1) % realtimeWaveformBuffer.length;
}

function drawRealtimeWaveform() {
    if (recordingState === 'idle') {
        realtimeWaveformCtx.clearRect(0, 0, realtimeWaveformCtx.canvas.width, realtimeWaveformCtx.canvas.height);
        return;
    }
    requestAnimationFrame(drawRealtimeWaveform);

    const w = realtimeWaveformCtx.canvas.width;
    const h = realtimeWaveformCtx.canvas.height;
    realtimeWaveformCtx.fillStyle = '#000';
    realtimeWaveformCtx.fillRect(0, 0, w, h);
    realtimeWaveformCtx.lineWidth = 2;
    realtimeWaveformCtx.strokeStyle = 'var(--primary)';
    
    realtimeWaveformCtx.beginPath();
    for (let i = 0; i < w; i++) {
        const index = (realtimeWaveformPos + i) % w;
        const val = realtimeWaveformBuffer[index] || 0;
        const y = (1 - val) * h / 2;
        if (i === 0) {
            realtimeWaveformCtx.moveTo(i, y);
        } else {
            realtimeWaveformCtx.lineTo(i, y);
        }
    }
    realtimeWaveformCtx.stroke();
    realtimeWaveformCtx.beginPath();
    for (let i = 0; i < w; i++) {
        const index = (realtimeWaveformPos + i) % w;
        const val = realtimeWaveformBuffer[index] || 0;
        const y = h - ((1 - val) * h / 2);
        if (i === 0) {
            realtimeWaveformCtx.moveTo(i, y);
        } else {
            realtimeWaveformCtx.lineTo(i, y);
        }
    }
    realtimeWaveformCtx.stroke();
}


// --- TRIMMER & EDITING ---
function openTrimmer() {
    const modal = document.getElementById('trimModal');
    modal.style.display = 'flex';
    const length = audioBuffer.reduce((sum, chunk) => sum + chunk.length, 0);
    fullAudioData = new Float32Array(length);
    let offset = 0;
    audioBuffer.forEach(chunk => {
        fullAudioData.set(chunk, offset);
        offset += chunk.length;
    });
    const duration = length / sampleRate;
    const sStart = document.getElementById('trimStart');
    const sEnd = document.getElementById('trimEnd');
    sStart.max = duration; sEnd.max = duration;
    sStart.value = 0; sEnd.value = duration;
    drawTrimWaveform();
    drawVolumeWaveform(); // Yêu cầu 4
}

// Yêu cầu 4: Vẽ biểu đồ âm lượng tổng
function drawVolumeWaveform() {
    const canvas = document.getElementById('volumeWaveformCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.clientWidth;
    const h = canvas.height = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    if (!fullAudioData) return;

    const step = Math.ceil(fullAudioData.length / w);
    const amp = h / 2;
    ctx.strokeStyle = 'rgba(255, 0, 85, 0.7)'; // Accent color
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0; i<w; i++){
        let min = 1.0, max = -1.0;
        for (let j=0; j<step; j++) {
            const val = fullAudioData[(i * step) + j] || 0;
            if (val < min) min = val; if (val > max) max = val;
        }
        ctx.moveTo(i, amp + min * amp);
        ctx.lineTo(i, amp + max * amp);
    }
    ctx.stroke();
}


function drawTrimWaveform() {
    const sStart = document.getElementById('trimStart');
    const sEnd = document.getElementById('trimEnd');
    // Logic để slider không bị trượt qua nhau
    if (parseFloat(sStart.value) >= parseFloat(sEnd.value)) sStart.value = parseFloat(sEnd.value) - 0.01;
    if (parseFloat(sEnd.value) <= parseFloat(sStart.value)) sEnd.value = parseFloat(sStart.value) + 0.01;

    const cvs = document.getElementById('trimCanvas');
    const ctx = cvs.getContext('2d');
    const w = cvs.width = cvs.clientWidth;
    const h = cvs.height = cvs.clientHeight;
    ctx.clearRect(0,0,w,h);

    const duration = fullAudioData.length / sampleRate;
    const startT = parseFloat(sStart.value);
    const endT = parseFloat(sEnd.value);
    const x1 = (startT / duration) * w;
    const x2 = (endT / duration) * w;

    ctx.fillStyle = 'rgba(0, 210, 255, 0.3)';
    ctx.fillRect(x1, 0, x2 - x1, h);
    ctx.fillStyle = '#fff';
    ctx.fillRect(x1 - 1, 0, 2, h);
    ctx.fillRect(x2 - 1, 0, 2, h);

    document.getElementById('startTimeDisplay').innerText = startT.toFixed(2)+'s';
    document.getElementById('endTimeDisplay').innerText = endT.toFixed(2)+'s';
}

function discardRecording() {
    if(confirm("Hủy bản thu này?")) {
        document.getElementById('trimModal').style.display = 'none';
        audioBuffer = []; fullAudioData = null;
    }
}


// --- SAVE WORKFLOW (Yêu cầu 2, 6, 8) ---
async function showProjectModal() {
    // Yêu cầu 8: Kiểm tra dung lượng trước khi lưu
    const { percentageUsed } = await checkStorageQuota();
    if (percentageUsed > 95) {
        alert("Lỗi: Bộ nhớ lưu trữ cục bộ đã gần đầy! Vui lòng xóa bớt các bản ghi cũ trước khi lưu bản ghi mới.");
        return;
    }

    document.getElementById('trimModal').style.display = 'none';
    const projectModal = document.getElementById('projectModal');
    const projectListDiv = document.getElementById('existing-projects-list');
    projectListDiv.innerHTML = 'Đang tải...';

    const tx = db.transaction('projects', 'readonly');
    const store = tx.objectStore('projects');
    const allProjects = store.getAll();

    allProjects.onsuccess = () => {
        projectListDiv.innerHTML = '';
        if (allProjects.result.length === 0) {
            projectListDiv.innerHTML = '<p style="padding: 20px; text-align: center; color: var(--text-muted);">Chưa có dự án nào.</p>';
        } else {
            allProjects.result.forEach(p => {
                const projectDiv = document.createElement('div');
                projectDiv.className = 'lyric-item'; // Tận dụng style có sẵn
                projectDiv.textContent = p.name;
                projectDiv.dataset.projectId = p.id;
                projectDiv.onclick = () => {
                    document.querySelectorAll('#existing-projects-list .lyric-item').forEach(el => el.classList.remove('selected'));
                    projectDiv.classList.add('selected');
                    document.getElementById('newProjectName').value = ''; // Xóa text nếu chọn project có sẵn
                }
                projectListDiv.appendChild(projectDiv);
            });
        }
    };
    projectModal.style.display = 'flex';
}

async function handleProjectSelection() {
    const selectedProjectEl = document.querySelector('#existing-projects-list .lyric-item.selected');
    const newProjectName = document.getElementById('newProjectName').value.trim();
    const currentLyrics = document.getElementById('lyricsInput').value.trim();

    let projectId, projectName;

    if (selectedProjectEl) {
        projectId = parseInt(selectedProjectEl.dataset.projectId);
        projectName = selectedProjectEl.textContent;
        
        // Yêu cầu 2: Kiểm tra lời bài hát có khác không
        const project = await getObjectById('projects', projectId);
        if (project.lyrics !== currentLyrics) {
            if (!confirm("Cảnh báo: Lời bài hát hiện tại khác với lời đã lưu trong dự án này. Bạn có muốn tiếp tục và ghi đè lời mới không?")) {
                return;
            }
            // Cập nhật lời mới cho dự án
            project.lyrics = currentLyrics;
            await updateObject('projects', project);
        }

    } else if (newProjectName) {
        const newProject = { name: newProjectName, lyrics: currentLyrics, createdAt: new Date() };
        projectId = await addObject('projects', newProject);
        projectName = newProjectName;
    } else {
        alert("Vui lòng chọn một dự án hoặc tạo một dự án mới.");
        return;
    }

    tempRecordingData = { projectId, projectName };
    document.getElementById('projectModal').style.display = 'none';
    showSaveModal();
}

// Yêu cầu 6: Hiển thị modal lưu file tùy chỉnh
function showSaveModal() {
    const modal = document.getElementById('saveModal');
    const input = document.getElementById('recordingNameInput');
    modal.style.display = 'flex';
    input.value = '';
    updateFileNamePreview();
    setTimeout(() => input.focus(), 100); // Focus vào ô nhập liệu
}

function updateFileNamePreview() {
    const customName = document.getElementById('recordingNameInput').value.trim() || '[tên tùy biến]';
    const date = new Date();
    const dateString = `${date.getFullYear().toString().slice(2)}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
    document.getElementById('fileNamePreview').textContent = `${customName}_${dateString}.wav`;
}


async function saveTrimmedAudio() {
    const customName = document.getElementById('recordingNameInput').value.trim();
    if (!customName) return alert("Vui lòng nhập tên cho bản thu.");

    const date = new Date();
    const dateString = `${date.getFullYear().toString().slice(2)}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
    const recordingName = `${customName}_${dateString}`;
    
    const startT = parseFloat(document.getElementById('trimStart').value);
    const endT = parseFloat(document.getElementById('trimEnd').value);
    const startSample = Math.floor(startT * sampleRate);
    const endSample = Math.floor(endT * sampleRate);
    const slicedData = fullAudioData.slice(startSample, endSample);
    const wavBlob = encodeWAV(slicedData, sampleRate);
    
    const record = {
        name: recordingName,
        blob: wavBlob,
        date: new Date(),
        projectId: tempRecordingData.projectId
    };

    await addObject('recs', record);
    
    document.getElementById('saveModal').style.display = 'none';
    loadProjectsAndRecordings();
    audioBuffer = []; fullAudioData = null; tempRecordingData = {};
    checkStorageQuota(); // Cập nhật lại dung lượng sau khi lưu
}

// --- PROJECT & PLAYLIST (Yêu cầu 2) ---
async function loadProjectsAndRecordings() {
    if(!db) return;
    const list = document.getElementById('project-list');
    list.innerHTML = '';
    
    const projects = await getAllObjects('projects');
    const recordings = await getAllObjects('recs');

    projects.sort((a, b) => b.createdAt - a.createdAt); // Sắp xếp dự án mới nhất lên đầu

    for (const project of projects) {
        const projectRecordings = recordings.filter(r => r.projectId === project.id);
        const div = document.createElement('div');
        div.className = 'project-item';
        div.dataset.projectId = project.id;
        
        let recordingsHTML = projectRecordings.length > 0
            ? projectRecordings.map(rec => {
                const url = URL.createObjectURL(rec.blob);
                return `
                    <div class="record-item" data-id="${rec.id}">
                        <div class="record-item-info">
                            <div style="font-weight:bold">${rec.name}</div>
                            <div style="font-size:0.8rem; color:#888">${rec.date.toLocaleString('vi-VN')}</div>
                        </div>
                        <audio controls src="${url}" style="height:35px;"></audio>
                        <a href="${url}" download="${rec.name.replace(/[^a-z0-9]/gi, '_')}.wav"><i class="fas fa-download"></i></a>
                    </div>
                `;
            }).join('')
            : '<p style="padding: 15px; color: var(--text-muted);">Dự án này chưa có bản ghi nào.</p>';

        div.innerHTML = `
            <div class="project-header">
                <span class="project-title">${project.name}</span>
                <span class="record-count" style="font-size: 0.8rem; color: #888;">${projectRecordings.length} bản ghi</span>
            </div>
            <div class="project-recordings">${recordingsHTML}</div>
        `;
        list.appendChild(div);

        div.querySelector('.project-header').onclick = () => {
            div.classList.toggle('open');
        };
    }
}

// --- FX & EQ LOGIC (Yêu cầu 3) ---
let eqNodes = [], reverbNode, reverbGain, dryGain;

function toggleFxSlidersLock(lock) {
    isFxSlidersLocked = lock;
    document.querySelectorAll('.fx-slider, .slider-value-input').forEach(el => {
        el.classList.toggle('locked', lock);
        if (lock) el.setAttribute('disabled', 'true');
        else el.removeAttribute('disabled');
    });
    const btn = document.getElementById('btnEditFX');
    btn.classList.toggle('locked', !lock);
    btn.textContent = lock ? 'Chỉnh sửa' : 'Khóa';
}

function saveFxPreset() {
    const name = prompt("Đặt tên cho cấu hình này:");
    if (!name) return;
    const preset = { name, settings: JSON.parse(JSON.stringify(fxState)) };
    addObject('fxPresets', preset).then(() => {
        alert('Đã lưu cấu hình!');
        loadFxPresets();
    });
}

async function loadFxPresets() {
    if(!db) return;
    const select = document.getElementById('fxPresetSelect');
    select.innerHTML = '<option value="">Chọn cấu hình...</option>';
    const presets = await getAllObjects('fxPresets');
    presets.forEach(p => {
        const option = new Option(p.name, p.id);
        select.add(option);
    });
}

async function loadSelectedFxPreset(id) {
    if (!id) return;
    const preset = await getObjectById('fxPresets', parseInt(id));
    if (preset) {
        fxState = preset.settings;
        // Update UI to match the new state
        Object.keys(fxState.eq).forEach(key => {
            const val = fxState.eq[key];
            document.querySelector(`.fx-slider[data-fx="eq-${key}"]`).value = val;
            document.querySelector(`.slider-value-input[data-fx="eq-${key}"]`).value = val;
        });
        document.querySelector('#reverbMix').value = fxState.reverb.mix;
        document.querySelector('.slider-value-input[data-fx="reverb-mix"]').value = fxState.reverb.mix;

        document.querySelectorAll('.reverb-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`.reverb-btn[data-type="${fxState.reverb.type}"]`).classList.add('active');
        
        applyEQSettings();
        applyReverbSettings();
    }
}

function buildFXChain(sourceNode) {
    const freqs = [60, 250, 1000, 4000, 12000];
    let prevNode = sourceNode;
    eqNodes = freqs.map((f, i) => {
        const eq = audioCtx.createBiquadFilter();
        eq.frequency.value = f;
        eq.type = i === 0 ? 'lowshelf' : (i === 4 ? 'highshelf' : 'peaking');
        prevNode.connect(eq);
        prevNode = eq;
        return eq;
    });
    dryGain = audioCtx.createGain();
    reverbGain = audioCtx.createGain();
    reverbNode = audioCtx.createConvolver();
    prevNode.connect(dryGain);
    prevNode.connect(reverbNode);
    reverbNode.connect(reverbGain);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    const mergePoint = audioCtx.createGain();
    dryGain.connect(mergePoint);
    reverbGain.connect(mergePoint);
    mergePoint.connect(analyser);
    applyEQSettings();
    applyReverbSettings();
}
function applyEQSettings() {
    if (!audioCtx || !eqNodes || eqNodes.length === 0) return;
    eqNodes[0].gain.value = fxState.eq.low;
    eqNodes[1].gain.value = fxState.eq.lowMid;
    eqNodes[2].gain.value = fxState.eq.mid;
    eqNodes[3].gain.value = fxState.eq.highMid;
    eqNodes[4].gain.value = fxState.eq.high;
}
function applyReverbSettings() {
    if (!audioCtx || !reverbGain) return;
    if (fxState.reverb.type === 'off') {
        reverbGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
    } else {
        setReverbImpulse(fxState.reverb.type);
        reverbGain.gain.setTargetAtTime(fxState.reverb.mix, audioCtx.currentTime, 0.01);
    }
}
function setReverbImpulse(type) {
    if (!audioCtx || !reverbNode) return;
    const duration = type === 'hall' ? 2.0 : (type === 'studio' ? 0.8 : 0.01);
    const decay = type === 'hall' ? 2.5 : 4.0;
    const length = sampleRate * duration;
    const impulse = audioCtx.createBuffer(2, length, sampleRate);
    for (let c = 0; c < 2; c++) {
        const data = impulse.getChannelData(c);
        for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
    }
    reverbNode.buffer = impulse;
}


// --- LYRICS & HELPER FUNCTIONS ---
function startLyricsScroll() {
    const el = document.getElementById('lyricsInput');
    lyricsScrollInterval = setInterval(() => {
        const speed = parseInt(document.getElementById('scrollSpeed').value);
        if(speed > 0) el.scrollTop += speed;
    }, 100);
}
function stopLyricsScroll() { clearInterval(lyricsScrollInterval); }

async function saveLyrics() {
    const content = document.getElementById('lyricsInput').value.trim();
    if (!content) return alert("Nội dung lời không được để trống.");
    const name = prompt("Đặt tên cho lời bài hát này:", `Lyrics ${new Date().toLocaleDateString()}`);
    if (!name) return;
    await addObject('lyrics', { name, content });
    alert('Đã lưu lời bài hát!');
    loadLyricsLibrary();
}

async function loadLyricsLibrary() {
    if (!db) return;
    const playlist = document.getElementById('lyrics-playlist');
    playlist.innerHTML = '';
    const lyrics = await getAllObjects('lyrics');
    lyrics.forEach(lyric => {
        const item = document.createElement('div');
        item.className = 'lyric-item';
        item.dataset.id = lyric.id;
        item.textContent = lyric.name;
        playlist.appendChild(item);
    });
}

async function loadSelectedLyrics(id) {
    document.querySelectorAll('#lyrics-playlist .lyric-item').forEach(item => {
        item.classList.toggle('selected', parseInt(item.dataset.id) === id);
    });
    const lyric = await getObjectById('lyrics', id);
    if (lyric) document.getElementById('lyricsInput').value = lyric.content;
}

async function deleteCurrentLyrics() {
    const selectedItem = document.querySelector('#lyrics-playlist .lyric-item.selected');
    if (!selectedItem) return alert("Vui lòng chọn một lời bài hát để xóa.");
    const id = parseInt(selectedItem.dataset.id);
    if (confirm(`Bạn có chắc muốn xóa lời bài hát "${selectedItem.textContent}"?`)) {
        await deleteObject('lyrics', id);
        document.getElementById('lyricsInput').value = '';
        loadLyricsLibrary();
    }
}

function encodeWAV(samples, sampleRate) {
    const buffer = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(buffer);
    const write = (o,s) => { for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); };
    write(0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true);
    write(8, 'WAVE'); write(12, 'fmt '); view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true); view.setUint16(34, 16, true);
    write(36, 'data'); view.setUint32(40, samples.length * 2, true);
    for (let i = 0; i < samples.length; i++) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
    return new Blob([view], { type: 'audio/wav' });
}

// --- IndexedDB HELPER PROMISES ---
function addObject(storeName, object) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction([storeName], 'readwrite');
        const store = tx.objectStore(storeName);
        const request = store.add(object);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}
function getObjectById(storeName, id) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction([storeName], 'readonly');
        const store = tx.objectStore(storeName);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}
function getAllObjects(storeName) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction([storeName], 'readonly');
        const store = tx.objectStore(storeName);
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}
function updateObject(storeName, object) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction([storeName], 'readwrite');
        const store = tx.objectStore(storeName);
        const request = store.put(object);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}
function deleteObject(storeName, id) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction([storeName], 'readwrite');
        const store = tx.objectStore(storeName);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
    });
}
</script>

</body>
</html>