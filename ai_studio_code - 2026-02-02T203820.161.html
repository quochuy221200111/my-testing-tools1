<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Vocal Studio Pro</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
    :root {
        --bg: #101010; --surface: #1e1e1e; --panel: #252525;
        --primary: #00d2ff; --secondary: #7b42f6; --accent: #ff0055; --warning: #ffc107;
        --text: #e0e0e0; --text-muted: #888;
        --border-color: #333;
    }
    /* YÊU CẦU 1: Tối ưu cho điện thoại */
    * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent; /* Loại bỏ highlight khi chạm trên mobile */
    }
    body {
        font-family: 'Inter', sans-serif; background-color: var(--bg); color: var(--text);
        margin: 0; display: flex; flex-direction: column; align-items: center;
        padding: 10px;
    }
    /* YÊU CẦU 5: Tối ưu không gian, bỏ tiêu đề */
    .main-container {
        display: grid;
        grid-template-columns: 1fr 380px;
        gap: 15px;
        width: 100%;
        max-width: 1300px;
        margin-top: 10px;
    }
    .panel { background: var(--panel); border-radius: 15px; padding: 20px; border: 1px solid var(--border-color); margin-bottom: 15px; }
    .panel-title { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; }
    /* YÊU CẦU 3: Chỉ icon mới kích hoạt cuộn */
    .panel-title .toggle-icon { cursor: pointer; padding: 5px; }
    .panel-content { max-height: 1000px; overflow: hidden; transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out, padding 0.5s ease-in-out; }
    .panel.collapsed .panel-content { max-height: 0; margin-top: 0 !important; padding-top: 0; padding-bottom: 0; overflow: hidden; }
    .panel.collapsed .panel-title { margin-bottom: 0; }
    .panel-title .toggle-icon { transition: transform 0.3s; }
    .panel.collapsed .toggle-icon { transform: rotate(-90deg); }

    /* YÊU CẦU 4: Biểu đồ âm lượng thời gian thực */
    .monitor-screen { background: #000; border-radius: 10px; height: 120px; position: relative; border: 1px solid #444; overflow: hidden; display: flex; align-items: center; justify-content: center; }
    canvas#realtimeVisualizer { width: 100%; height: 100%; display: block; position: absolute; top:0; left:0; z-index: 1; }
    .timer-overlay { position: absolute; bottom: 10px; right: 15px; font-family: monospace; color: var(--primary); font-size: 1.2rem; z-index: 10; text-shadow: 0 0 5px #000; }

    .control-group { margin-bottom: 15px; }
    /* YÊU CẦU 3: Cải thiện thanh trượt */
    .slider-container { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
    .slider-label { width: 80px; font-size: 0.8rem; color: #aaa; flex-shrink: 0; }
    input[type=range] { flex-grow: 1; accent-color: var(--primary); height: 4px; background: #444; border-radius: 2px; -webkit-appearance: none; min-width: 50px; }
    input[type=range]:disabled { opacity: 0.5; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 15px; height: 15px; background: white; border-radius: 50%; cursor: pointer; }
    input[type=range]:disabled::-webkit-slider-thumb { cursor: not-allowed; }
    .slider-value-input { width: 50px; background: #333; border: 1px solid #555; color: var(--text); border-radius: 5px; text-align: center; font-size: 0.8rem; padding: 2px; }
    .slider-value-input:disabled { background: #222; color: #777; }
    .fx-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;}

    /* YÊU CẦU 1: Nút Ghi/Dừng/Pause */
    .main-controls { display: flex; justify-content: center; align-items: center; gap: 20px; margin: 20px 0; }
    .btn-control { border: none; font-size: 1.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; color: white; }
    #btnRecordPause { width: 70px; height: 70px; border-radius: 50%; background: var(--primary); box-shadow: 0 8px 15px rgba(0, 210, 255, 0.2); }
    #btnRecordPause.recording { background: var(--accent); animation: pulse 1.5s infinite; box-shadow: 0 8px 15px rgba(255, 0, 85, 0.3); }
    #btnRecordPause.paused { background: var(--warning); }
    #btnStop { width: 50px; height: 50px; border-radius: 15px; background: #333; color: #666; pointer-events: none; opacity: 0.5; }
    #btnStop.active { background: #444; color: white; pointer-events: all; opacity: 1; }

    .fx-buttons { display: flex; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
    .fx-btn { flex-grow: 1; background: transparent; color: var(--text-muted); border: none; padding: 10px 5px; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; font-size: 0.8rem; }
    .fx-btn:not(:last-child) { border-right: 1px solid var(--border-color); }
    .fx-btn:hover { background-color: #333; }
    .fx-btn.active { background: var(--primary); color: #000; font-weight: 600; }

    .lyrics-container { position: relative; height: 300px; background: #151515; border-radius: 10px; overflow: hidden; border: 1px solid var(--border-color); }
    #lyricsInput { width: 100%; height: 100%; background: transparent; color: #ddd; border: none; padding: 20px; font-size: 1.1rem; line-height: 1.6; resize: none; outline: none; box-sizing: border-box; font-family: 'Inter', sans-serif; }

    /* YÊU CẦU 2: Giao diện Project */
    .project-group { margin-bottom: 15px; background: #2a2a2a; border-radius: 8px; border: 1px solid #444;}
    .project-header { padding: 10px 15px; font-weight: bold; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
    .project-header .toggle-icon { transition: transform 0.3s; }
    .project-recordings { max-height: 500px; overflow-y: auto; transition: max-height 0.4s ease-out; padding: 0 10px 10px 10px; }
    .project-group.collapsed .project-recordings { max-height: 0; padding: 0; }
    .project-group.collapsed .project-header .toggle-icon { transform: rotate(-90deg); }

    .record-item { background: #333; padding: 8px 12px; border-radius: 8px; margin-bottom: 8px; display: flex; align-items: center; gap: 15px; transition: 0.2s; }
    .record-item.selected { background-color: #303f5a; }
    .record-item-info { flex-grow: 1; }

    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; align-items: center; justify-content: center; }
    .modal-content { background: var(--surface); padding: 20px; border-radius: 15px; width: 95%; max-width: 800px; text-align: center; }
    .trim-canvas-container { width: 100%; height: 150px; background: #000; position: relative; margin: 20px 0; border: 1px solid #444; }
    #trimCanvas { position: absolute; top:0; left:0; width:100%; height:100%;}
    .trim-controls { display:flex; flex-wrap: wrap; gap:20px; justify-content:center; }
    .btn-save { background: var(--primary); color: #000; border: none; padding: 10px 20px; border-radius: 5px; font-weight: bold; cursor: pointer; }
    
    /* YÊU CẦU 6: Form đặt tên file */
    .filename-input-group { display: flex; align-items: center; justify-content: center; gap: 5px; margin-bottom: 15px; }
    .filename-input-group input { flex-grow: 1; max-width: 300px; }
    .filename-input-group .date-suffix { background: #333; padding: 8px; border-radius: 5px; font-family: monospace; }
    input.form-input { background: #111; border: 1px solid #444; color: var(--text); padding: 8px 12px; border-radius: 5px; }
    
    /* YÊU CẦU 7: Giao diện cảnh báo và trạng thái bộ nhớ */
    #storageWarning { display: none; background-color: var(--warning); color: #000; padding: 10px; border-radius: 8px; margin: 10px 0; font-weight: bold; }
    #storageStatus { font-size: 0.8rem; color: var(--text-muted); margin-top: 15px; text-align: center; }
    .progress-bar { background: #444; border-radius: 5px; overflow: hidden; height: 10px; }
    .progress-bar-inner { background: var(--secondary); height: 100%; transition: width 0.5s ease; }

    @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.4); } 70% { box-shadow: 0 0 0 20px rgba(255, 0, 85, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); } }
    
    /* YÊU CẦU 1: Tối ưu responsive */
    @media (max-width: 900px) {
        body { padding: 5px; }
        .main-container { grid-template-columns: 1fr; }
        .trim-controls { flex-direction: column; align-items: center; }
        .panel { padding: 15px; }
        .modal-content { padding: 15px; }
    }
</style>
</head>
<body>

<!-- YÊU CẦU 7: Giao diện cảnh báo bộ nhớ -->
<div id="storageWarning"></div>

<div class="main-container">
    <!-- CỘT TRÁI: ĐIỀU KHIỂN & HÌNH ẢNH -->
    <div>
        <div class="panel">
            <div class="monitor-screen">
                <!-- YÊU CẦU 4: Canvas cho biểu đồ âm lượng thời gian thực -->
                <canvas id="realtimeVisualizer"></canvas>
                <div id="timer" class="timer-overlay">00:00:0</div>
            </div>
        </div>

        <!-- YÊU CẦU 1: Giao diện nút điều khiển mới -->
        <div class="main-controls">
            <button id="btnRecordPause" class="btn-control" title="Bắt đầu ghi âm"><i class="fas fa-microphone"></i></button>
            <button id="btnStop" class="btn-control" title="Dừng & Lưu"><i class="fas fa-stop"></i></button>
        </div>

        <div class="panel fx-panel">
            <div class="panel-title">
                <span>Hiệu ứng & EQ</span>
                <!-- YÊU CẦU 3: Icon để cuộn -->
                <i class="fas fa-sliders-h toggle-icon"></i>
            </div>
            <div class="panel-content">
                <!-- YÊU CẦU 3: Nút Edit và quản lý preset -->
                <div class="fx-header">
                     <button id="btnEditSliders" class="btn-small-icon" title="Chỉnh sửa thanh trượt"><i class="fas fa-lock"></i></button>
                     <div>
                         <select id="presetSelector" class="form-input" style="padding: 4px;"></select>
                         <button id="btnSavePreset" class="btn-small-icon" title="Lưu Preset"><i class="fas fa-save"></i></button>
                     </div>
                </div>
                
                <div class="control-group">
                    <div class="slider-container"><span class="slider-label">Low</span><input type="range" class="fx-slider" data-param="eq.low" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-param="eq.low" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Low-Mid</span><input type="range" class="fx-slider" data-param="eq.lowMid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-param="eq.lowMid" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Mid</span><input type="range" class="fx-slider" data-param="eq.mid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-param="eq.mid" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Hi-Mid</span><input type="range" class="fx-slider" data-param="eq.highMid" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-param="eq.highMid" value="0"></div>
                    <div class="slider-container"><span class="slider-label">High</span><input type="range" class="fx-slider" data-param="eq.high" min="-12" max="12" value="0" step="1"><input type="number" class="slider-value-input" data-param="eq.high" value="0"></div>
                </div>
                 <div class="control-group">
                    <div class="fx-buttons">
                        <button class="fx-btn reverb-btn active" data-type="off">Tắt Reverb</button>
                        <button class="fx-btn reverb-btn" data-type="studio">Studio</button>
                        <button class="fx-btn reverb-btn" data-type="hall">Hội trường</button>
                    </div>
                    <div class="slider-container" style="margin-top:15px;">
                        <span class="slider-label">Reverb Mix</span>
                        <input type="range" id="reverbMix" class="fx-slider" data-param="reverb.mix" min="0" max="1" step="0.01" value="0.3">
                        <input type="number" class="slider-value-input" data-param="reverb.mix" value="0.3" step="0.1" min="0" max="1">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CỘT PHẢI: LYRICS & THƯ VIỆN -->
    <div>
        <div class="panel lyrics-panel">
            <div class="panel-title"><span>Lời bài hát</span> <i class="fas fa-music toggle-icon"></i></div>
            <div class="panel-content">
                 <div class="lyrics-container">
                    <textarea id="lyricsInput" placeholder="Dán lời bài hát vào đây..."></textarea>
                </div>
            </div>
        </div>

        <div class="panel playlist-panel">
            <div class="panel-title">
                <span>Thư viện</span>
                <i class="fas fa-list-ul toggle-icon"></i>
            </div>
            <div class="panel-content">
                <!-- YÊU CẦU 2: Playlist sẽ được JS render theo Project -->
                <div id="playlist" class="playlist"></div>
                <!-- YÊU CẦU 7: Hiển thị trạng thái bộ nhớ -->
                <div id="storageStatus">
                    <div class="progress-bar"><div class="progress-bar-inner"></div></div>
                    <span class="status-text"></span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- MODAL CHỈNH SỬA & LƯU -->
<div id="trimModal" class="modal">
    <div class="modal-content">
        <h2 style="color:var(--text)">Chỉnh sửa & Lưu bản thu</h2>
        <p style="color:#888; font-size:0.9rem;">Kéo để chọn vùng âm thanh bạn muốn giữ lại.</p>
        
        <!-- YÊU CẦU 4: Canvas cho biểu đồ tổng thể khi cắt -->
        <div class="trim-canvas-container">
            <canvas id="trimCanvas"></canvas>
        </div>

        <div class="trim-controls control-group">
             <div><span class="slider-label">Bắt đầu: </span><span id="startTimeDisplay">0.0s</span><input type="range" id="trimStart" value="0" step="0.01"></div>
             <div><span class="slider-label">Kết thúc: </span><span id="endTimeDisplay">0.0s</span><input type="range" id="trimEnd" value="100" step="0.01"></div>
        </div>
        
        <!-- YÊU CẦU 6: Form đặt tên file -->
        <div class="filename-input-group">
            <input type="text" id="customFileName" class="form-input" placeholder="Đặt tên bản thu...">
            <span id="fileNameDateSuffix" class="date-suffix"></span>
        </div>

        <!-- YÊU CẦU 2: Lưu vào Project -->
        <div class="control-group">
            <select id="projectSelectorModal" class="form-input" style="width:100%; max-width: 350px;">
                <option value="new">-- Tạo dự án mới --</option>
            </select>
            <input type="text" id="newProjectName" class="form-input" placeholder="Tên dự án mới..." style="width:100%; max-width: 350px; margin-top: 5px;">
        </div>

        <div style="margin-top:20px;">
            <button id="btnCancelTrim" class="btn-cancel">Hủy bỏ</button>
            <button id="btnSave" class="btn-save"><i class="fas fa-save"></i> Lưu bản thu</button>
        </div>
    </div>
</div>

<script>
// --- GLOBAL STATE & DOM ELEMENTS ---
let db;
let audioCtx, micStream, micSource, workletNode, analyser;
let recordingState = 'idle'; // idle, recording, paused
let audioBuffer = [];
let fullAudioData, sampleRate;
let timerInterval, startTime, elapsedTime = 0;
let slidersLocked = true;

// YÊU CẦU 4: State cho biểu đồ thời gian thực
let volumeHistory = [];
const MAX_VOLUME_HISTORY = 256;

// YÊU CẦU 3: State cho hiệu ứng
let fxState = {
    reverb: { type: 'off', mix: 0.3 },
    eq: { low: 0, lowMid: 0, mid: 0, highMid: 0, high: 0 }
};

const DOMElements = {
    btnRecordPause: document.getElementById('btnRecordPause'),
    btnStop: document.getElementById('btnStop'),
    timer: document.getElementById('timer'),
    trimModal: document.getElementById('trimModal'),
    btnSave: document.getElementById('btnSave'),
    btnCancelTrim: document.getElementById('btnCancelTrim'),
    customFileName: document.getElementById('customFileName'),
    fileNameDateSuffix: document.getElementById('fileNameDateSuffix'),
    projectSelectorModal: document.getElementById('projectSelectorModal'),
    newProjectName: document.getElementById('newProjectName'),
    btnEditSliders: document.getElementById('btnEditSliders'),
    fxPanel: document.querySelector('.fx-panel'),
    storageStatusText: document.querySelector('#storageStatus .status-text'),
    storageProgressBar: document.querySelector('#storageStatus .progress-bar-inner'),
    storageWarning: document.getElementById('storageWarning'),
    playlist: document.getElementById('playlist'),
    lyricsInput: document.getElementById('lyricsInput'),
    presetSelector: document.getElementById('presetSelector'),
    btnSavePreset: document.getElementById('btnSavePreset')
};

// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', () => {
    initDB();
    setupEventListeners();
    toggleSliderLock(true);
    updateUIForState();
});

function initDB() {
    const req = indexedDB.open("VocalStudioDB_V3", 3); // Tăng version để upgrade schema
    req.onupgradeneeded = e => {
        db = e.target.result;
        if (!db.objectStoreNames.contains('recs')) {
            const recStore = db.createObjectStore('recs', { keyPath: 'id', autoIncrement: true });
            recStore.createIndex('projectId', 'projectId', { unique: false });
        }
        if (!db.objectStoreNames.contains('projects')) {
            db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
        }
        // YÊU CẦU 3: Store cho presets
        if (!db.objectStoreNames.contains('presets')) {
            db.createObjectStore('presets', { keyPath: 'id', autoIncrement: true });
        }
    };
    req.onsuccess = e => {
        db = e.target.result;
        // YÊU CẦU 7: Yêu cầu Persistent Storage & Theo dõi dung lượng
        requestPersistentStorage();
        checkStorageQuota();
        loadProjectsAndRecordings();
        loadPresets();
    };
    req.onerror = e => console.error("DB Error:", e.target.errorCode);
}

// YÊU CẦU 7.1: TRIỂN KHAI LƯU TRỮ BỀN VỮNG
async function requestPersistentStorage() {
    if (navigator.storage && navigator.storage.persist) {
        const isPersisted = await navigator.storage.persisted();
        if (!isPersisted) {
            const result = await navigator.storage.persist();
            console.log(`Persistent Storage request status: ${result ? 'Granted' : 'Denied'}`);
            if (!result) {
                alert("Lưu ý: Trình duyệt không cấp quyền lưu trữ bền vững. Dữ liệu có thể bị xóa nếu ổ đĩa đầy.");
            }
        }
    }
}

// YÊU CẦU 7.2: THEO DÕI VÀ CẢNH BÁO DUNG LƯỢNG
async function checkStorageQuota(showWarning = true) {
    if (navigator.storage && navigator.storage.estimate) {
        const { usage, quota } = await navigator.storage.estimate();
        const usageMB = (usage / 1024 / 1024).toFixed(2);
        const quotaMB = (quota / 1024 / 1024).toFixed(2);
        const percentageUsed = (usage / quota) * 100;

        // YÊU CẦU 7.3: CẬP NHẬT UI
        DOMElements.storageStatusText.textContent = `Bộ nhớ đã dùng: ${usageMB} MB / ${quotaMB} MB`;
        DOMElements.storageProgressBar.style.width = `${percentageUsed}%`;

        if (showWarning) {
            if (percentageUsed > 80) {
                DOMElements.storageWarning.innerHTML = `Cảnh báo: Bộ nhớ cục bộ đã sử dụng ${percentageUsed.toFixed(0)}% (${usageMB} MB / ${quotaMB} MB). Vui lòng tải xuống các bản ghi cũ để tránh bị lỗi lưu.`;
                DOMElements.storageWarning.style.display = 'block';
            } else {
                DOMElements.storageWarning.style.display = 'none';
            }
        }
        return { usage, quota, percentageUsed };
    }
    return null;
}

function setupEventListeners() {
    DOMElements.btnRecordPause.onclick = handleRecordPauseClick;
    DOMElements.btnStop.onclick = stopRecording;

    // YÊU CẦU 3: Chỉ icon mới kích hoạt cuộn
    document.querySelectorAll('.panel-title .toggle-icon').forEach(icon => {
        icon.onclick = (e) => {
            e.stopPropagation();
            icon.closest('.panel').classList.toggle('collapsed');
        };
    });
    
    // Listeners cho hiệu ứng & sliders
    DOMElements.btnEditSliders.onclick = () => toggleSliderLock();
    DOMElements.fxPanel.addEventListener('input', handleFxChange);
    document.querySelectorAll('.reverb-btn').forEach(btn => {
        btn.onclick = () => {
            if (slidersLocked) return;
            fxState.reverb.type = btn.dataset.type;
            document.querySelectorAll('.reverb-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            applyReverbSettings();
        };
    });
    DOMElements.btnSavePreset.onclick = saveCurrentPreset;
    DOMElements.presetSelector.onchange = (e) => loadPreset(parseInt(e.target.value));


    // Listeners cho Modal
    DOMElements.btnCancelTrim.onclick = discardRecording;
    DOMElements.btnSave.onclick = handleSave;
    document.getElementById('trimStart').oninput = drawTrimWaveform;
    document.getElementById('trimEnd').oninput = drawTrimWaveform;
    DOMElements.projectSelectorModal.onchange = () => {
         DOMElements.newProjectName.style.display = DOMElements.projectSelectorModal.value === 'new' ? 'block' : 'none';
    };
    
    DOMElements.playlist.addEventListener('click', (e) => {
        if (e.target.closest('.project-header')) {
            e.target.closest('.project-group').classList.toggle('collapsed');
        }
    });
}

// --- AUDIO ENGINE ---
const workletCode = `class RecorderProcessor extends AudioWorkletProcessor { 
    process(inputs) { 
        if (inputs[0][0]) {
            this.port.postMessage(inputs[0][0]); 
        }
        return true; 
    } 
} 
registerProcessor('recorder-processor', RecorderProcessor);`;

async function initAudio() {
    if (audioCtx) return;
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
        sampleRate = audioCtx.sampleRate;
        micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, channelCount: 1 }});
        micSource = audioCtx.createMediaStreamSource(micStream);
        buildFXChain(micSource);
        const blob = new Blob([workletCode.trim()], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        await audioCtx.audioWorklet.addModule(url);
        workletNode = new AudioWorkletNode(audioCtx, 'recorder-processor');
        workletNode.port.onmessage = (event) => {
            if (recordingState === 'recording' && event.data) {
                const data = new Float32Array(event.data);
                audioBuffer.push(data);
                
                // YÊU CẦU 4: Tính toán âm lượng cho biểu đồ
                let sumSquares = 0.0;
                for (const sample of data) { sumSquares += sample * sample; }
                const rms = Math.sqrt(sumSquares / data.length);
                volumeHistory.push(rms);
                if(volumeHistory.length > MAX_VOLUME_HISTORY) volumeHistory.shift();
            }
        };
        analyser.connect(workletNode);
        // Không kết nối workletNode đến destination để tránh nghe thấy chính mình (monitor)
    } catch (err) {
        console.error("Lỗi khởi tạo audio:", err);
        alert("Không thể truy cập microphone. Vui lòng cấp quyền và thử lại.");
        recordingState = 'idle';
        updateUIForState();
    }
}


// --- RECORDING CONTROLS ---
async function handleRecordPauseClick() {
    if (recordingState === 'idle') {
        await initAudio();
        if (!audioCtx) return; // Nếu init thất bại
        recordingState = 'recording';
        audioBuffer = [];
        elapsedTime = 0;
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 100);
        drawRealtimeVisualizer();
    } else if (recordingState === 'recording') {
        recordingState = 'paused';
        elapsedTime += Date.now() - startTime;
        clearInterval(timerInterval);
    } else if (recordingState === 'paused') {
        recordingState = 'recording';
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 100);
    }
    updateUIForState();
}

function stopRecording() {
    if (recordingState === 'idle') return;
    recordingState = 'stopped';
    clearInterval(timerInterval);
    
    if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micStream = null;
    }
    if (audioCtx) {
        audioCtx.close().then(() => { audioCtx = null; });
    }
    
    if (audioBuffer.length > 0) {
        openTrimmer();
    } else {
        recordingState = 'idle';
    }
    updateUIForState();
}

function updateUIForState() {
    const icon = DOMElements.btnRecordPause.querySelector('i');
    switch(recordingState) {
        case 'idle':
            DOMElements.btnRecordPause.classList.remove('recording', 'paused');
            DOMElements.btnRecordPause.title = 'Bắt đầu ghi âm';
            icon.className = 'fas fa-microphone';
            DOMElements.btnStop.classList.remove('active');
            DOMElements.timer.innerText = "00:00:0";
            break;
        case 'recording':
            DOMElements.btnRecordPause.classList.add('recording');
            DOMElements.btnRecordPause.classList.remove('paused');
            DOMElements.btnRecordPause.title = 'Tạm dừng';
            icon.className = 'fas fa-pause';
            DOMElements.btnStop.classList.add('active');
            break;
        case 'paused':
            DOMElements.btnRecordPause.classList.add('paused');
            DOMElements.btnRecordPause.classList.remove('recording');
            DOMElements.btnRecordPause.title = 'Tiếp tục ghi âm';
            icon.className = 'fas fa-play';
            DOMElements.btnStop.classList.add('active');
            break;
        case 'stopped':
            DOMElements.btnRecordPause.classList.remove('recording', 'paused');
            DOMElements.btnRecordPause.title = 'Bắt đầu ghi âm';
            icon.className = 'fas fa-microphone';
            DOMElements.btnStop.classList.remove('active');
            break;
    }
}

function updateTimer() {
    const currentDuration = elapsedTime + (Date.now() - startTime);
    const totalMilliseconds = Math.floor(currentDuration);
    const totalSeconds = Math.floor(totalMilliseconds / 1000);
    const m = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
    const s = (totalSeconds % 60).toString().padStart(2, '0');
    const ms = Math.floor((totalMilliseconds % 1000) / 100).toString();
    DOMElements.timer.innerText = `${m}:${s}:${ms}`;
}

// --- VISUALIZATION ---
function drawRealtimeVisualizer() {
    if (recordingState !== 'recording' && recordingState !== 'paused') {
        return;
    }
    const canvas = document.getElementById('realtimeVisualizer');
    const ctx = canvas.getContext('2d');
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'var(--primary)';
    ctx.beginPath();
    
    const sliceWidth = canvas.width / (MAX_VOLUME_HISTORY - 1);
    
    for (let i = 0; i < volumeHistory.length; i++) {
        const v = volumeHistory[i] * canvas.height * 2.5; // Tăng biên độ để dễ nhìn
        const y = canvas.height - v;
        if (i === 0) {
            ctx.moveTo(i * sliceWidth, y);
        } else {
            ctx.lineTo(i * sliceWidth, y);
        }
    }
    
    ctx.stroke();
    requestAnimationFrame(drawRealtimeVisualizer);
}

// --- FX & PRESETS ---
let eqNodes = [], reverbNode, reverbGain, dryGain;

function buildFXChain(sourceNode) {
    const freqs = [60, 250, 1000, 4000, 12000];
    let prevNode = sourceNode;
    eqNodes = freqs.map((f, i) => {
        const eq = audioCtx.createBiquadFilter();
        eq.frequency.value = f;
        eq.type = i === 0 ? 'lowshelf' : (i === 4 ? 'highshelf' : 'peaking');
        prevNode.connect(eq);
        prevNode = eq;
        return eq;
    });

    dryGain = audioCtx.createGain();
    reverbGain = audioCtx.createGain();
    reverbNode = audioCtx.createConvolver();
    prevNode.connect(dryGain);
    prevNode.connect(reverbNode);
    reverbNode.connect(reverbGain);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    const mergePoint = audioCtx.createGain();
    dryGain.connect(mergePoint);
    reverbGain.connect(mergePoint);
    mergePoint.connect(analyser);

    applyEQSettings();
    applyReverbSettings();
}

function applyEQSettings() {
    if (!audioCtx || !eqNodes || eqNodes.length === 0) return;
    eqNodes[0].gain.value = fxState.eq.low;
    eqNodes[1].gain.value = fxState.eq.lowMid;
    eqNodes[2].gain.value = fxState.eq.mid;
    eqNodes[3].gain.value = fxState.eq.highMid;
    eqNodes[4].gain.value = fxState.eq.high;
}

function applyReverbSettings() {
    if (!audioCtx || !reverbGain) return;
    if (fxState.reverb.type === 'off') {
        reverbGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
    } else {
        setReverbImpulse(fxState.reverb.type);
        reverbGain.gain.setTargetAtTime(fxState.reverb.mix, audioCtx.currentTime, 0.01);
    }
}

function setReverbImpulse(type) {
    if (!audioCtx || !reverbNode) return;
    const duration = type === 'hall' ? 2.0 : 0.8;
    const decay = type === 'hall' ? 2.5 : 4.0;
    const length = sampleRate * duration;
    const impulse = audioCtx.createBuffer(2, length, sampleRate);
    for (let c = 0; c < 2; c++) {
        const data = impulse.getChannelData(c);
        for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
    }
    reverbNode.buffer = impulse;
}

// YÊU CẦU 3: Quản lý thanh trượt và presets
function toggleSliderLock(forceLock) {
    slidersLocked = forceLock !== undefined ? forceLock : !slidersLocked;
    const icon = DOMElements.btnEditSliders.querySelector('i');
    icon.className = slidersLocked ? 'fas fa-lock' : 'fas fa-lock-open';
    DOMElements.fxPanel.querySelectorAll('.fx-slider, .slider-value-input').forEach(el => {
        el.disabled = slidersLocked;
    });
}

function handleFxChange(e) {
    const el = e.target;
    if (el.matches('.fx-slider, .slider-value-input')) {
        const paramPath = el.dataset.param.split('.');
        let value = el.type === 'range' ? parseFloat(el.value) : parseInt(el.value);
        if (paramPath.length === 2) fxState[paramPath[0]][paramPath[1]] = value;
        
        // Cập nhật giá trị tương ứng
        const otherInput = DOMElements.fxPanel.querySelector(`[data-param="${el.dataset.param}"]:not([type="${el.type}"])`);
        if (otherInput) otherInput.value = value;
        
        applyEQSettings();
        applyReverbSettings();
    }
}

async function saveCurrentPreset() {
    const name = prompt("Đặt tên cho preset này:");
    if (!name || !name.trim()) return;
    
    const preset = { name, state: fxState };
    const tx = db.transaction(['presets'], 'readwrite');
    tx.objectStore('presets').add(preset);
    tx.oncomplete = () => {
        alert("Đã lưu preset!");
        loadPresets();
    };
}

async function loadPresets() {
    const tx = db.transaction(['presets'], 'readonly');
    const store = tx.objectStore('presets');
    const presets = await store.getAll();
    
    DOMElements.presetSelector.innerHTML = '<option value="">-- Chọn Preset --</option>';
    presets.forEach(p => {
        const option = new Option(p.name, p.id);
        DOMElements.presetSelector.add(option);
    });
}

async function loadPreset(id) {
    if (!id) return;
    const tx = db.transaction(['presets'], 'readonly');
    const preset = await tx.objectStore('presets').get(id);
    
    fxState = preset.state;
    updateFxUIFromState();
    applyEQSettings();
    applyReverbSettings();
}

function updateFxUIFromState() {
    // Cập nhật sliders và number inputs
    for (const [key, value] of Object.entries(fxState.eq)) {
        DOMElements.fxPanel.querySelectorAll(`[data-param="eq.${key}"]`).forEach(el => el.value = value);
    }
    DOMElements.fxPanel.querySelectorAll(`[data-param="reverb.mix"]`).forEach(el => el.value = fxState.reverb.mix);
    
    // Cập nhật nút reverb
    document.querySelectorAll('.reverb-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.type === fxState.reverb.type);
    });
}

// --- TRIMMER & EDITING ---
function openTrimmer() {
    DOMElements.trimModal.style.display = 'flex';
    const length = audioBuffer.reduce((sum, chunk) => sum + chunk.length, 0);
    fullAudioData = new Float32Array(length);
    let offset = 0;
    audioBuffer.forEach(chunk => {
        fullAudioData.set(chunk, offset);
        offset += chunk.length;
    });

    const duration = length / sampleRate;
    const sStart = document.getElementById('trimStart');
    const sEnd = document.getElementById('trimEnd');
    sStart.max = duration; sEnd.max = duration;
    sStart.value = 0; sEnd.value = duration;

    // YÊU CẦU 6: Hiển thị hậu tố ngày và focus
    const now = new Date();
    const yy = now.getFullYear().toString().slice(-2);
    const mm = (now.getMonth() + 1).toString().padStart(2, '0');
    const dd = now.getDate().toString().padStart(2, '0');
    DOMElements.fileNameDateSuffix.textContent = `_${yy}${mm}${dd}`;
    DOMElements.customFileName.value = '';
    setTimeout(() => DOMElements.customFileName.focus(), 100);

    loadProjectsForModal();
    drawTrimWaveform();
}

function drawTrimWaveform() {
    // ... code vẽ waveform như cũ ...
    const sStart = document.getElementById('trimStart'), sEnd = document.getElementById('trimEnd');
    if (parseFloat(sStart.value) >= parseFloat(sEnd.value)) sStart.value = parseFloat(sEnd.value) - 0.01;
    if (parseFloat(sEnd.value) <= parseFloat(sStart.value)) sEnd.value = parseFloat(sStart.value) + 0.01;
    
    const cvs = document.getElementById('trimCanvas'), ctx = cvs.getContext('2d');
    const w = cvs.width = cvs.clientWidth, h = cvs.height = cvs.clientHeight;
    ctx.clearRect(0,0,w,h);
    const step = Math.ceil(fullAudioData.length / w), amp = h / 2;
    ctx.strokeStyle = '#555'; ctx.lineWidth = 1; ctx.beginPath();
    for(let i=0; i<w; i++){
        let min = 1.0, max = -1.0;
        for (let j=0; j<step; j++) {
            const val = fullAudioData[(i * step) + j] || 0;
            if (val < min) min = val; if (val > max) max = val;
        }
        ctx.moveTo(i, amp + min * amp); ctx.lineTo(i, amp + max * amp);
    }
    ctx.stroke();

    const duration = fullAudioData.length / sampleRate;
    const startT = parseFloat(sStart.value), endT = parseFloat(sEnd.value);
    const x1 = (startT / duration) * w, x2 = (endT / duration) * w;
    ctx.fillStyle = 'rgba(0, 210, 255, 0.3)'; ctx.fillRect(x1, 0, x2 - x1, h);
    ctx.fillStyle = '#fff'; ctx.fillRect(x1 - 1, 0, 2, h); ctx.fillRect(x2 - 1, 0, 2, h);
    document.getElementById('startTimeDisplay').innerText = startT.toFixed(2)+'s';
    document.getElementById('endTimeDisplay').innerText = endT.toFixed(2)+'s';
}

async function handleSave() {
    // YÊU CẦU 7.2: Kiểm tra dung lượng trước khi lưu
    const storageInfo = await checkStorageQuota(false);
    if (storageInfo && storageInfo.percentageUsed > 95) {
        alert("Lỗi: Bộ nhớ gần đầy! Vui lòng xóa bớt các bản ghi cũ trước khi lưu bản ghi mới.");
        return;
    }

    const customName = DOMElements.customFileName.value.trim();
    if (!customName) {
        alert("Vui lòng đặt tên cho bản thu.");
        DOMElements.customFileName.focus();
        return;
    }

    // YÊU CẦU 6: Tạo tên file hoàn chỉnh
    const finalName = customName + DOMElements.fileNameDateSuffix.textContent;

    const startT = parseFloat(document.getElementById('trimStart').value);
    const endT = parseFloat(document.getElementById('trimEnd').value);
    const startSample = Math.floor(startT * sampleRate);
    const endSample = Math.floor(endT * sampleRate);
    const slicedData = fullAudioData.slice(startSample, endSample);
    const wavBlob = encodeWAV(slicedData, sampleRate);
    const currentLyrics = DOMElements.lyricsInput.value;

    const selectedProjectId = DOMElements.projectSelectorModal.value;
    let projectId;

    if (selectedProjectId === 'new') {
        const newProjectName = DOMElements.newProjectName.value.trim();
        if (!newProjectName) {
            alert("Vui lòng đặt tên cho dự án mới.");
            return;
        }
        projectId = await createNewProject(newProjectName, currentLyrics);
    } else {
        projectId = parseInt(selectedProjectId);
        // YÊU CẦU 2: Kiểm tra lời bài hát có khớp không
        const project = await getProjectById(projectId);
        if (project.lyrics !== currentLyrics) {
            if (!confirm("Lời bài hát hiện tại khác với lời trong dự án. Bạn có muốn tiếp tục lưu và ghi đè lời của dự án bằng lời mới không?")) {
                return;
            }
            // Cập nhật lời của dự án
            await updateProjectLyrics(projectId, currentLyrics);
        }
    }
    
    saveRecordingToDB(finalName, wavBlob, projectId);
}

function saveRecordingToDB(name, blob, projectId) {
    const recording = { name, blob, date: new Date(), projectId };
    const tx = db.transaction(['recs'], 'readwrite');
    tx.objectStore('recs').add(recording);
    tx.oncomplete = () => {
        closeAndResetModal();
        loadProjectsAndRecordings();
        checkStorageQuota(); // Cập nhật lại UI bộ nhớ sau khi lưu
    };
    tx.onerror = (e) => console.error("Save recording error", e.target.error);
}

function discardRecording() {
    if(confirm("Hủy bản thu này?")) {
        closeAndResetModal();
    }
}

function closeAndResetModal() {
    DOMElements.trimModal.style.display = 'none';
    audioBuffer = []; 
    fullAudioData = null;
    recordingState = 'idle';
    updateUIForState();
}

function encodeWAV(samples, sampleRate) {
    // ... code encode WAV như cũ ...
    const buffer = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(buffer);
    const write = (o,s) => { for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); };
    write(0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true);
    write(8, 'WAVE'); write(12, 'fmt '); view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true); view.setUint16(34, 16, true);
    write(36, 'data'); view.setUint32(40, samples.length * 2, true);
    for (let i = 0; i < samples.length; i++) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
    return new Blob([view], { type: 'audio/wav' });
}

// --- PROJECTS & PLAYLIST ---
async function createNewProject(name, lyrics) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(['projects'], 'readwrite');
        const req = tx.objectStore('projects').add({ name, lyrics });
        req.onsuccess = (e) => resolve(e.target.result);
        req.onerror = (e) => reject(e.target.error);
    });
}

async function getProjectById(id) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(['projects'], 'readonly');
        const req = tx.objectStore('projects').get(id);
        req.onsuccess = (e) => resolve(e.target.result);
        req.onerror = (e) => reject(e.target.error);
    });
}

async function updateProjectLyrics(id, lyrics) {
     const project = await getProjectById(id);
     project.lyrics = lyrics;
     const tx = db.transaction(['projects'], 'readwrite');
     tx.objectStore('projects').put(project);
}

async function loadProjectsForModal() {
    const tx = db.transaction(['projects'], 'readonly');
    const store = tx.objectStore('projects');
    const projects = await new Promise(resolve => store.getAll().onsuccess = e => resolve(e.target.result));
    
    DOMElements.projectSelectorModal.innerHTML = '<option value="new">-- Tạo dự án mới --</option>';
    projects.forEach(p => {
        const option = new Option(p.name, p.id);
        DOMElements.projectSelectorModal.add(option);
    });
    DOMElements.projectSelectorModal.dispatchEvent(new Event('change'));
}

// YÊU CẦU 2: Render playlist theo project
async function loadProjectsAndRecordings() {
    if(!db) return;
    DOMElements.playlist.innerHTML = 'Đang tải...';

    const projectTx = db.transaction(['projects'], 'readonly');
    const recTx = db.transaction(['recs'], 'readonly');

    const projects = await new Promise(res => projectTx.objectStore('projects').getAll().onsuccess = e => res(e.target.result));
    const recs = await new Promise(res => recTx.objectStore('recs').getAll().onsuccess = e => res(e.target.result));

    DOMElements.playlist.innerHTML = '';
    
    if (projects.length === 0 && recs.length > 0) {
        // Xử lý các bản ghi không thuộc dự án nào
        const recordingsHTML = recs.map(rec => createRecordingItemHTML(rec)).join('');
        DOMElements.playlist.innerHTML = `<p style="color:var(--text-muted); font-size:0.8rem;">Các bản ghi chưa được phân loại:</p>` + recordingsHTML;
        return;
    }
    
    projects.sort((a,b) => b.id - a.id); // Sắp xếp dự án mới nhất lên đầu
    
    projects.forEach(project => {
        const projectRecordings = recs.filter(r => r.projectId === project.id).sort((a,b) => b.date - a.date);
        const projectGroup = document.createElement('div');
        projectGroup.className = 'project-group collapsed';
        projectGroup.dataset.projectId = project.id;
        
        projectGroup.innerHTML = `
            <div class="project-header">
                <span>${project.name} (${projectRecordings.length})</span>
                <i class="fas fa-chevron-down toggle-icon"></i>
            </div>
            <div class="project-recordings">
                ${projectRecordings.map(rec => createRecordingItemHTML(rec)).join('') || '<p style="font-size:0.8rem; color:#888; padding: 10px;">Chưa có bản ghi nào.</p>'}
            </div>
        `;
        DOMElements.playlist.appendChild(projectGroup);
    });
}

function createRecordingItemHTML(rec) {
    const url = URL.createObjectURL(rec.blob);
    return `
        <div class="record-item" data-id="${rec.id}">
            <div class="record-item-info">
                <div style="font-weight:bold">${rec.name}</div>
                <div style="font-size:0.8rem; color:#888">${rec.date.toLocaleString('vi-VN')}</div>
            </div>
            <audio controls src="${url}" style="height:35px;" class="player"></audio>
            <a href="${url}" download="${rec.name.replace(/[^a-z0-9]/gi, '_')}.wav" class="download-btn"><i class="fas fa-download"></i></a>
        </div>
    `;
}

</script>
</body>
</html>