
<!DOCTYPE html>
<html>
<head>
<title>S·∫Øp x·∫øp ·∫£nh & B·∫£ng t√≠nh th√¥ng minh - Giao di·ªán m·ªõi</title>
<meta charset="UTF-8">
<!-- Y√äU C·∫¶U 1: Th√™m th∆∞ vi·ªán html2canvas ƒë·ªÉ ch·ª•p ·∫£nh m√†n h√¨nh -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<style>
    /* === CSS CHUNG === */
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; background-color: #f4f4f4; color: #333; }
    h3 { margin: 0 0 10px 0; font-size: 1.1em; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; }
    textarea { width: 100%; box-sizing: border-box; }

    /* === Y√äU C·∫¶U 1: THU G·ªåN GIAO DI·ªÜN === */
    button, label.custom-file-label, select { padding: 5px 10px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; transition: background-color 0.2s; white-space: nowrap; text-align: center; }
    button:hover, label.custom-file-label:hover { opacity: 0.85; }
    button:disabled { background-color: #ccc; cursor: not-allowed; }
    input[type="file"].custom-file-input { display: none; }

    /* === B·ªê C·ª§C T·ªîNG TH·ªÇ === */
    .page-wrapper { display: flex; height: 100vh; gap: 15px; transition: margin-left 0.3s ease-in-out; }
    
    /* === Y√äU C·∫¶U 3: CSS CHO THANH C√îNG C·ª§ T·ª∞ ƒê·ªòNG CU·ªòN === */
    #toolbar {
        position: fixed; top: 0; left: 0; width: 450px; /* ƒê·ªô r·ªông c·ªßa thanh c√¥ng c·ª• */
        height: 100vh; background-color: #fff; border-right: 1px solid #ddd;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1); z-index: 2000;
        transform: translateX(-100%); transition: transform 0.3s ease-in-out;
        display: flex; flex-direction: column; padding: 8px; box-sizing: border-box;
    }
    #toolbar.visible { transform: translateX(0); }
    .page-wrapper.toolbar-pinned { margin-left: 450px; /* ƒê·∫©y n·ªôi dung ch√≠nh sang ph·∫£i khi toolbar ƒë∆∞·ª£c ghim */ }
    .toolbar-content { overflow-y: auto; /* Cho ph√©p cu·ªôn n·∫øu n·ªôi dung qu√° d√†i */ display: flex; flex-direction: column; gap: 8px; height: 100%; }
    #pin-toolbar-btn {
        position: absolute; top: 10px; right: -30px; /* N·∫±m ngay b√™n ngo√†i thanh c√¥ng c·ª• */
        width: 30px; height: 30px; border-radius: 0 5px 5px 0; border-left: none;
        font-size: 18px; line-height: 30px; padding: 0; background-color: #6c757d;
    }
    
    .main-column { flex: 1; display: flex; flex-direction: column; min-width: 500px; overflow-y: hidden; transition: all 0.3s ease; }
    .main-content { padding: 15px; overflow-y: auto; flex-grow: 1; }
    .preview-column {
        width: 50%; max-width: 50%; flex-shrink: 0; background-color: #e9ecef;
        padding: 15px; display: flex; flex-direction: column; position: sticky;
        top: 0; height: 100vh; box-sizing: border-box; transition: all 0.3s ease;
    }
    .page-wrapper.preview-hidden .preview-column { display: none; }
    .page-wrapper.grid-hidden .main-column { display: none; }
    .page-wrapper.grid-hidden .preview-column { width: 100%; max-width: 100%; }

    .control-wrapper { display: flex; gap: 10px; width: 100%; }
    .control-area { flex: 1; display: flex; }
    .control-group { display: flex; flex-direction: column; gap: 5px; padding: 8px; border: 1px solid #e0e0e0; border-radius: 5px; background-color: #fcfcfc; width: 100%; }
    .action-buttons, .name-options { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
    .action-buttons > * { flex-grow: 1; }
    .action-buttons label { display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 13px; }

    #paste-zone { padding: 6px; border: 2px dashed #ccc; border-radius: 4px; text-align: center; color: #666; background-color: #fafafa; transition: background-color 0.2s, border-color 0.2s; font-size: 13px; }
    #paste-zone.drag-over { background-color: #e0e0e0; border-color: #007bff; }
    #name-list { resize: vertical; min-height: 40px; height: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; line-height: 1.5; white-space: pre; font-size: 12px; }
    #range-inputs-container { display: flex; gap: 5px; align-items: center; }
    #range-inputs-container input[type="number"] { width: 45px; padding: 3px; font-size: 12px; }
    
    #progress-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: none; /* S·∫Ω ƒë∆∞·ª£c ƒëi·ªÅu khi·ªÉn b·∫±ng JS */ justify-content: center; align-items: center; z-index: 9999; flex-direction: column; color: white; }
    .progress-bar-container { width: 50%; max-width: 500px; background: #fff; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    #progress-text { margin: 0 0 10px 0; font-size: 1.1em; color: #333; }
    #upload-progress, #download-progress { width: 100%; height: 15px; display: block; /* Hi·ªÉn th·ªã trong container */ margin-top: 8px; }
    #upload-progress::-webkit-progress-bar, #download-progress::-webkit-progress-bar { background-color: #eee; border-radius: 5px; }
    #upload-progress::-webkit-progress-value { background-color: #28a745; border-radius: 5px; transition: width 0.1s linear; }
    #download-progress::-webkit-progress-value { background-color: #007bff; border-radius: 5px; transition: width 0.1s linear; }
    
    #numeric-mode-controls .control-group { gap: 8px; } #numeric-mode-controls h3 { font-size: 1em; text-align: center; margin-bottom: 5px; } #numeric-mode-controls .options-container { display: flex; flex-direction: column; gap: 8px; } #numeric-mode-controls .option-row { display: flex; align-items: center; gap: 8px; } #numeric-mode-controls label { white-space: nowrap; font-size: 13px; } #numeric-mode-controls select { padding: 4px 8px; font-size: 12px; } #numeric-mode-controls textarea { min-height: 40px !important; font-size: 12px; } #numeric-mode-controls .action-row { display:flex; gap: 8px; } #numeric-mode-controls .action-row button { flex: 1; }
    
    .hotkey-setting { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 5px; } .hotkey-setting label { font-size: 13px; white-space: nowrap; } .hotkey-setting input { width: 100px; text-align: center; padding: 2px 4px; border: 1px solid #ccc; border-radius: 3px; }
    #local-note-area { min-height: 80px; resize: vertical; font-size: 13px; }

    #large-preview-container { flex-grow: 1; display: flex; align-items: center; justify-content: center; background-color: #333; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); overflow: hidden; min-height: 0; position: relative; cursor: grab; user-select: none; } #large-preview-container:active { cursor: grabbing; } #large-preview-img { max-width: 100%; max-height: 100%; object-fit: contain; transform-origin: center center; will-change: transform; pointer-events: none; user-select: none; -webkit-user-drag: none; } .preview-placeholder { color: #ccc; font-size: 1.2em; pointer-events: none; } .preview-controls { display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center; flex-wrap: wrap; gap: 5px; } #preview-name-input { flex-grow: 1; margin: 0 10px; padding: 4px 6px; border: 1px solid #ccc; border-radius: 3px; font-size: 13px; } .rotate-controls { display: flex; gap: 5px; } #suggestion-buttons-container { margin-top: 10px; } #suggestion-buttons { display:flex; flex-wrap:wrap; gap:5px; } #suggestion-buttons button.suggestion-selected { background-color: #28a745; border: 2px solid #1e7e34; font-weight: bold; }
    #fine-grained-suggestions { margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd; display:flex; flex-wrap:wrap; gap:4px; min-height: 25px; } #fine-grained-suggestions button { font-size: 11px; padding: 3px 6px; background-color: #6c757d; }
    
    .photo-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; } .photo-grid.dense-mode { grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); gap: 8px; } .photo-grid.dense-mode .name-container input[type="text"] { font-size: 9px; padding: 1px 2px; height: 20px; } .photo-wrapper.hidden-by-filter { display: none; } .photo-wrapper { position: relative; display: flex; flex-direction: column; align-items: center; } .img-container { position: relative; width: 100%; padding-top: 75%; overflow: hidden; border-radius: 4px; background-color: #eee; cursor: pointer; transition: outline 0.2s ease-in-out, border 0.2s; }
    /* Y√äU C·∫¶U 7: TƒÉng ƒë·ªô d√†y vi·ªÅn v√† ƒë·ªïi m√†u */
    .photo-wrapper.is-tall .img-container { border: 5px solid red; } 
    .photo-wrapper.is-small .img-container { border: 5px solid gold; }
    .photo-item { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border: none; pointer-events: none; } .delete-btn, .exclude-numeric-btn, .replace-btn { position: absolute; z-index: 10; width: 22px; height: 22px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 14px; line-height: 22px; text-align: center; padding: 0; opacity: 0; transition: opacity 0.2s; } .delete-btn { top: 4px; right: 4px; } .exclude-numeric-btn { top: 4px; left: 4px; display: none; } body.numeric-mode .exclude-numeric-btn { display: block; }
    .replace-btn { bottom: 4px; left: 4px; font-size: 16px; }
    .replace-panel { display: none; position: absolute; bottom: 30px; left: 4px; z-index: 20; background: white; border: 1px solid #ccc; border-radius: 4px; padding: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); flex-direction: column; gap: 5px; } .replace-panel button { width: 100%; font-size: 12px; }
    .photo-wrapper:hover .delete-btn, .photo-wrapper:hover .exclude-numeric-btn, .photo-wrapper:hover .replace-btn { opacity: 1; } .name-container { display: flex; align-items: center; width: 100%; margin-top: 5px; } .name-container input[type="text"] { flex: 1; padding: 3px 4px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 3px; min-width: 0; font-size: 10.5px; height: 24px; }

    .ghost-class { opacity: 0.4; background-color: #c0e0ff; border: 2px dashed #007bff; } .drag-class { opacity: 0.8; transform: scale(1.05); } .selected-photo .img-container { outline: 3px solid #007bff; outline-offset: 2px; } @keyframes yellow-flash { from { outline: 4px solid gold; } to { outline: 4px solid transparent; } } .newly-added .img-container { animation: yellow-flash 1.5s ease-out; }

    /* === CSS CHO B·∫¢NG T√çNH TH√îNG MINH (ƒê√É T√çCH H·ª¢P) === */
    #smart-grid-panel.floating { position: fixed; z-index: 3000; background-color: #fcfcfc; box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 1px solid #ccc; border-radius: 5px; resize: both; overflow: auto; min-width: 400px; min-height: 200px; transition: background-color 0.3s ease, border-color 0.3s ease; }
    #smart-grid-panel.floating > h3 { cursor: move; user-select: none; }
    #smart-grid-panel .panel-header { display: flex; justify-content: space-between; align-items: center; }
    #smart-grid-panel .panel-header .drag-handle { flex-grow: 1; cursor: move; user-select: none; }
    #smart-grid-panel .panel-actions { display: flex; align-items: center; gap: 5px; }
    #smart-grid-panel .panel-actions button { background: none; border: none; font-size: 18px; cursor: pointer; padding: 0 5px; color: #555; }
    #smart-grid-panel .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; align-items: center; }
    #smart-grid-panel .controls input[type="number"] { padding: 4px; border: 1px solid #ccc; border-radius: 4px; width: 60px; font-size: 12px; }
    #smart-grid-panel .controls button { padding: 5px 10px; font-size: 13px; }
    #smart-grid-panel #mic-button { background: none; border: none; font-size: 22px; cursor: pointer; padding: 0; color: #42526e; }
    #smart-grid-panel #mic-button.recording { color: red; }
    #smart-grid-panel .info { margin-left: auto; color: #5e6c84; font-size: 11px; }
    #smart-grid-panel #grid-container { width: 100%; max-height: 400px; overflow: auto; border: 1px solid #dfe1e6; }
    #smart-grid-panel table { border-collapse: collapse; width: 100%; table-layout: fixed; }
    #smart-grid-panel th, #smart-grid-panel td { border: 1px solid #dfe1e6; padding: 6px; text-align: left; min-width: 80px; height: 22px; box-sizing: border-box; outline: none; font-size: 12px; }
    #smart-grid-panel th { background-color: #f4f5f7; font-weight: 600; text-align: center; position: relative; }
    
    /* === Y√äU C·∫¶U 1: CSS CHO T√çNH NƒÇNG KH√ìA C·ªòT === */
    #smart-grid-panel th .lock-btn { cursor: pointer; margin-left: 5px; font-size: 12px; opacity: 0.5; }
    #smart-grid-panel th:hover .lock-btn { opacity: 1; }
    #smart-grid-panel th.locked-col { background-color: #e9ecef; }
    #smart-grid-panel td.locked-cell { 
        background-color: #f8f9fa; 
        color: #6c757d; 
        cursor: not-allowed;
        user-select: none; /* NgƒÉn ch·ªçn vƒÉn b·∫£n */
    }
    /* ƒê·∫£m b·∫£o √¥ b·ªã kh√≥a kh√¥ng nh·∫≠n focus */
    #smart-grid-panel td[contenteditable="false"] {
        outline: none;
    }

    /* === Y√äU C·∫¶U 2: CSS CHO CH·∫æ ƒê·ªò G∆Ø∆†NG (N·ªÄN TRONG SU·ªêT) === */
    #smart-grid-panel.floating.mirror-mode {
        /* S·ª≠ d·ª•ng bi·∫øn CSS ƒë·ªÉ JS c√≥ th·ªÉ ƒëi·ªÅu khi·ªÉn ƒë·ªô trong su·ªët */
        background-color: rgba(252, 252, 252, var(--panel-opacity, 0.7));
        border: 1px solid rgba(204, 204, 204, var(--panel-opacity, 0.7));
    }
    #smart-grid-panel.mirror-mode .controls,
    #smart-grid-panel.mirror-mode .panel-header {
         background-color: rgba(244, 245, 247, var(--panel-opacity, 0.85)); /* L√†m cho v√πng ƒëi·ªÅu khi·ªÉn ƒë·ª° trong su·ªët h∆°n m·ªôt ch√∫t */
    }
    /* ƒê·∫£m b·∫£o c√°c th√†nh ph·∫ßn b√™n trong b·∫£ng c≈©ng trong su·ªët ƒë·ªÉ n·ªÅn panel hi·ªán ra */
    #smart-grid-panel.mirror-mode table,
    #smart-grid-panel.mirror-mode th,
    #smart-grid-panel.mirror-mode td {
        background-color: transparent !important;
        border-color: rgba(223, 225, 230, var(--panel-opacity, 0.7));
    }
    /* Ch·ªØ b√™n trong v·∫´n gi·ªØ nguy√™n m√†u v√† ƒë·ªô ƒë·∫≠m, kh√¥ng b·ªã trong su·ªët */
    #smart-grid-panel.mirror-mode td,
    #smart-grid-panel.mirror-mode th {
        color: #333; /* ƒê·∫∑t l·∫°i m√†u ch·ªØ ƒë·ªÉ ch·∫Øc ch·∫Øn kh√¥ng b·ªã ·∫£nh h∆∞·ªüng */
    }
    #smart-grid-panel.mirror-mode td.selected {
         background-color: rgba(233, 242, 255, 0.9) !important; /* Gi·ªØ cho √¥ ƒë∆∞·ª£c ch·ªçn v·∫´n n·ªïi b·∫≠t */
    }

    #smart-grid-panel td.selected { background-color: #e9f2ff !important; border: 2px solid #0052cc; }
    #smart-grid-panel .highlight-number { font-weight: bold; }
    #smart-grid-panel .cluster-focus { font-weight: bold; outline: 2px solid #0065ff; background-color: #e9f2ff; border-radius: 3px; }

</style>
</head>
<body id="page-body">

<div id="progress-overlay">
    <div class="progress-bar-container">
        <p id="progress-text">ƒêang x·ª≠ l√Ω...</p>
        <progress id="upload-progress" value="0" max="100"></progress>
        <progress id="download-progress" value="0" max="100" style="display:none;"></progress>
    </div>
</div>

<div id="toolbar">
    <button id="pin-toolbar-btn" title="Ghim/B·ªè ghim thanh c√¥ng c·ª• (T·ª± ƒë·ªông l∆∞u)">üìå</button>
    <div class="toolbar-content">
        <div class="control-wrapper">
            <div class="control-area">
                <div class="control-group">
                    <div class="action-buttons">
                        <label for="photo-input" class="custom-file-label">T·∫£i ·∫£nh/ZIP</label>
                        <div id="paste-zone">Ho·∫∑c k√©o th·∫£ / d√°n ·∫£nh</div>
                        <button id="clear-btn" style="background-color: #dc3545;">X√≥a t·∫•t c·∫£</button>
                        <button id="delete-selected-btn" style="background-color: #ffc107; color: #333;">X√≥a ƒë√£ ch·ªçn</button>
                        <button id="download-all-btn">T·∫£i t·∫•t c·∫£</button>
                        <button id="undo-btn">Ho√†n t√°c</button>
                        <button id="grid-toggle-btn" style="background-color: #6c757d;">Ch·∫ø ƒë·ªô l∆∞·ªõi x2</button>
                        <button id="toggle-preview-btn">·∫®n Preview</button>
                        <button id="hide-all-images-btn" style="background-color: #6c757d;">·∫®n/Hi·ªán L∆∞·ªõi ·∫¢nh</button>
                        <button id="highlight-tall-btn">·∫¢nh d·ªçc</button>
                        <button id="numeric-filter-btn" style="background-color: #17a2b8;">Ch·∫ø ƒë·ªô S·ªë li·ªáu</button>
                         <!-- N√∫t B·∫≠t/T·∫Øt B·∫£ng T√≠nh -->
                        <button id="toggle-smart-grid-btn" style="background-color: #17a2b8;">B·∫£ng t√≠nh</button>
                        <button id="prev-image-btn" title="Chuy·ªÉn ƒë·∫øn ·∫£nh ph√≠a tr∆∞·ªõc">·∫¢nh Tr∆∞·ªõc</button>
                        <button id="next-image-btn" title="Chuy·ªÉn ƒë·∫øn ·∫£nh k·∫ø ti·∫øp">·∫¢nh Sau</button>
                        <label><input type="checkbox" id="lock-toggle"> Kh√≥a</label>
                        <label><input type="checkbox" id="smart-select-toggle"> B·∫≠t ch·ªçn s·ªë</label>
                    </div>
                </div>
            </div>
        </div>
        <div class="control-wrapper">
             <div class="control-area">
                <div class="control-group">
                    <div class="name-options">
                        <textarea id="name-list" placeholder="Danh s√°ch t√™n..."></textarea>
                        <div style="display:flex; flex-direction:column; gap: 5px; align-self: flex-end; width: 100%;">
                            <div id="range-name-options">
                                <label><input type="checkbox" id="range-name-toggle"> Ch√®n t√™n theo kho·∫£ng</label>
                                <div id="range-inputs-container" style="display: none;">
                                    <label for="name-range-start">T·ª´:</label>
                                    <input type="number" id="name-range-start" value="1" min="1">
                                    <label for="name-range-end">ƒê·∫øn:</label>
                                    <input type="number" id="name-range-end" value="10" min="1">
                                    <label title="S·ª≠ d·ª•ng d√≤ng ƒë·∫ßu ti√™n trong danh s√°ch t√™n cho t·∫•t c·∫£ ·∫£nh trong kho·∫£ng ƒë√£ ch·ªçn"><input type="checkbox" id="apply-single-name-toggle"> D√πng 1 t√™n</label>
                                </div>
                            </div>
                            <button id="assign-names-btn">Ch√®n t√™n t·ª´ danh s√°ch</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="numeric-mode-controls" class="control-wrapper" style="display: none;">
            <div class="control-group" style="width:100%;">
                <h3 style="text-align:center;">T√πy ch·ªçn Ch·∫ø ƒë·ªô S·ªë li·ªáu</h3>
                <div class="options-container">
                    <div class="option-row">
                        <label for="suggestion-count-select">S·ªë g·ª£i √Ω m·ªói ·∫£nh:</label>
                        <select id="suggestion-count-select">
                            <option value="1">1</option> <option value="3" selected>3</option> <option value="5">5</option> <option value="7">7</option> <option value="9">9</option>
                        </select>
                        <textarea id="numeric-name-suggestions" placeholder="D√°n danh s√°ch t√™n g·ª£i √Ω v√†o ƒë√¢y..." style="flex-grow:1;"></textarea>
                    </div>
                     <div class="option-row">
                         <label for="numeric-filtered-names-list">Danh s√°ch t√™n ·∫£nh ƒëang hi·ªÉn th·ªã:</label>
                         <textarea id="numeric-filtered-names-list" readonly placeholder="T√™n c√°c ·∫£nh ƒë√£ l·ªçc s·∫Ω hi·ªán ·ªü ƒë√¢y..." style="flex-grow:1; background-color: #e9ecef;"></textarea>
                     </div>
                    <div class="action-row">
                        <button id="apply-numeric-suggestions-btn">G√°n T√™n G·ª£i √ù</button>
                        <button id="download-numeric-btn" style="background-color: #28a745;">T·∫£i ·∫£nh ƒë√£ l·ªçc</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- === PANEL B·∫¢NG T√çNH TH√îNG MINH (M·ªöI) === -->
        <div class="control-group" id="smart-grid-panel" style="display: none;">
            <div class="panel-header">
                <h3 class="drag-handle">B·∫£ng T√≠nh Th√¥ng Minh</h3>
                <div class="panel-actions">
                    <!-- Y√äU C·∫¶U 2: Th√™m b·ªô ƒëi·ªÅu khi·ªÉn ch·∫ø ƒë·ªô g∆∞∆°ng -->
                     <div id="sg-mirror-controls" style="display: flex; align-items: center; gap: 5px;">
                         <label for="sg-opacity-slider" style="font-size: 12px; display: none; color: #333;">Trong su·ªët:</label>
                         <input type="range" id="sg-opacity-slider" min="0.1" max="0.95" step="0.05" value="0.7" style="display: none; margin-right: 5px;" title="ƒêi·ªÅu ch·ªânh ƒë·ªô trong su·ªët">
                     </div>
                     <button id="sg-mirror-btn" title="Ch·∫ø ƒë·ªô G∆∞∆°ng (N·ªÅn trong su·ªët)">üëª</button>
                     <button id="sg-float-btn" title="B·∫≠t/T·∫Øt ch·∫ø ƒë·ªô n·ªïi">‚ú•</button>
                </div>
            </div>
            <div class="controls">
                <label for="sg-rows">H√†ng:</label>
                <input type="number" id="sg-rows" value="50" min="1">
                <label for="sg-cols">C·ªôt:</label>
                <input type="number" id="sg-cols" value="5" min="1">
                <button id="sg-create-grid">T·∫°o B·∫£ng</button>
                <button id="sg-undo-btn" title="Ho√†n t√°c">‚Ü∂</button>
                <button id="sg-redo-btn" title="L√†m l·∫°i">‚Ü∑</button>
                <button id="mic-button" title="Nh·∫≠p li·ªáu b·∫±ng gi·ªçng n√≥i">üé§</button>
                <button id="sg-prev-cluster-btn" title="L√πi l·∫°i m·ªôt √¥ d·ªØ li·ªáu">‚Üê</button>
                <button id="sg-next-cluster-btn" title="Ti·∫øn t·ªõi m·ªôt √¥ d·ªØ li·ªáu">‚Üí</button>
                <div class="info">D√πng ph√≠m t·∫Øt ƒë·ªÉ ghi √¢m & chuy·ªÉn √¥</div>
            </div>
            <div id="grid-container"></div>
        </div>
        <!-- === K·∫æT TH√öC PANEL === -->

        <div class="control-group">
            <h3>Ghi ch√∫ (T·ª± ƒë·ªông l∆∞u)</h3>
            <textarea id="local-note-area" placeholder="Ghi ch√∫ nhanh c·ªßa b·∫°n..."></textarea>
        </div>
        
        <div class="control-group">
            <h3>C√†i ƒë·∫∑t chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n (T·ª± ƒë·ªông l∆∞u)</h3>
            <textarea id="text-replacement-rules" placeholder="Nh·∫≠p quy t·∫Øc, m·ªói d√≤ng m·ªôt quy t·∫Øc.&#10;V√≠ d·ª•:&#10;m·ªôt,1&#10;hai,2&#10;ch·∫•m,.&#10;ph·∫©y,," style="min-height: 80px; font-size: 12px;"></textarea>
            <p style="font-size: 11px; color: #666; margin: 2px 0 0 0;">C√°c quy t·∫Øc n√†y s·∫Ω t·ª± ƒë·ªông √°p d·ª•ng khi nh·∫≠p li·ªáu b·∫±ng gi·ªçng n√≥i.</p>
        </div>

        <div class="control-group">
            <h3>C√†i ƒë·∫∑t ph√≠m t·∫Øt (T·ª± ƒë·ªông l∆∞u)</h3>
            <div id="hotkey-settings">
                 <div class="hotkey-setting"><label for="hotkey-next-image">Chuy·ªÉn ·∫£nh ti·∫øp theo:</label><input type="text" id="hotkey-next-image" data-action="nextImage"></div>
                <div class="hotkey-setting"><label for="hotkey-prev-image">Chuy·ªÉn ·∫£nh ph√≠a tr∆∞·ªõc:</label><input type="text" id="hotkey-prev-image" data-action="prevImage"></div>
                <div class="hotkey-setting"><label for="hotkey-edit-name">S·ª≠a t√™n ·∫£nh (preview):</label><input type="text" id="hotkey-edit-name" data-action="editName"></div>
                <div class="hotkey-setting"><label for="hotkey-rotate-left">Xoay tr√°i:</label><input type="text" id="hotkey-rotate-left" data-action="rotateLeft"></div>
                 <div class="hotkey-setting"><label for="hotkey-rotate-right">Xoay ph·∫£i:</label><input type="text" id="hotkey-rotate-right" data-action="rotateRight"></div>
                <div class="hotkey-setting"><label for="hotkey-pin-toolbar">Ghim/B·ªè ghim thanh c√¥ng c·ª•:</label><input type="text" id="hotkey-pin-toolbar" data-action="pinToolbar"></div>
                <div class="hotkey-setting"><label for="hotkey-voice-input">Nh·∫≠p gi·ªçng n√≥i (·∫¢nh):</label><input type="text" id="hotkey-voice-input" data-action="voiceInput"></div>
                <div class="hotkey-setting"><label for="hotkey-translate-name">D·ªãch t√™n sang Ti·∫øng Anh:</label><input type="text" id="hotkey-translate-name" data-action="translateName"></div>
                <!-- PH√çM T·∫ÆT CHO B·∫¢NG T√çNH (M·ªöI) -->
                <div class="hotkey-setting" style="border-top: 1px solid #ddd; padding-top: 5px; margin-top: 5px;"><label for="hotkey-sg-voice">Ghi √¢m (B·∫£ng t√≠nh):</label><input type="text" id="hotkey-sg-voice" data-action="smartGridVoice"></div>
                <div class="hotkey-setting"><label for="hotkey-sg-prev">Ch·ªçn s·ªë l√πi l·∫°i (B·∫£ng t√≠nh):</label><input type="text" id="hotkey-sg-prev" data-action="smartGridPrev"></div>
                <div class="hotkey-setting"><label for="hotkey-sg-next">Ch·ªçn s·ªë ti·∫øp (B·∫£ng t√≠nh):</label><input type="text" id="hotkey-sg-next" data-action="smartGridNext"></div>
            </div>
        </div>
    </div>
</div>

<div class="page-wrapper" id="page-wrapper">
    <div class="main-column">
        <div class="main-content" id="main-content">
            <div id="photo-grid-main" class="photo-grid"></div>
        </div>
    </div>
    <div class="preview-column">
        <div class="preview-controls">
            <h3>Xem tr∆∞·ªõc ·∫£nh</h3>
            <input type="text" id="preview-name-input" placeholder="S·ª≠a t√™n t·∫°i ƒë√¢y..." style="display: none;">
            <div class="rotate-controls">
                <button id="rotate-left-btn" title="Xoay tr√°i 90 ƒë·ªô">‚Ü∫</button>
                <button id="rotate-right-btn" title="Xoay ph·∫£i 90 ƒë·ªô">‚Üª</button>
                <button id="flip-horizontal-btn" title="L·∫≠t ngang">‚Üî</button>
                <button id="flip-vertical-btn" title="L·∫≠t d·ªçc">‚Üï</button>
                <button id="voice-input-btn" title="K√≠ch ho·∫°t nh·∫≠p li·ªáu gi·ªçng n√≥i (d√πng ph√≠m t·∫Øt)">üé§</button>
            </div>
            <button id="capture-btn" title="Copy v√πng hi·ªÉn th·ªã v√†o Clipboard (T·ª∑ l·ªá 4:3)">üìã</button>
        </div>
        <div id="large-preview-container">
            <span id="preview-placeholder" class="preview-placeholder">Ch·ªçn ·∫£nh ƒë·ªÉ xem. LƒÉn chu·ªôt ƒë·ªÉ Zoom, Gi·ªØ chu·ªôt tr√°i ƒë·ªÉ K√©o.</span>
            <img id="large-preview-img" src="" alt="" draggable="false">
        </div>
        <div id="suggestion-buttons-container" style="display: none;">
            <h4>Ch·ªçn t√™n ch√≠nh th·ª©c:</h4>
            <div id="suggestion-buttons"></div>
            <div id="fine-grained-suggestions"></div>
        </div>
    </div>
</div>
<input type="file" id="photo-input" multiple accept="image/*,.zip,application/octet-stream" class="custom-file-input">

<script>
// --- C√°c bi·∫øn to√†n c·ª•c (S·∫Øp x·∫øp ·∫£nh) ---
const photoInput = document.getElementById('photo-input');
const clearBtn = document.getElementById('clear-btn');
const assignNamesBtn = document.getElementById('assign-names-btn');
const downloadAllBtn = document.getElementById('download-all-btn');
const undoBtn = document.getElementById('undo-btn');
const lockToggle = document.getElementById('lock-toggle');
const pasteZone = document.getElementById('paste-zone');
const mainContentEl = document.getElementById('main-content');
const nameListTextArea = document.getElementById('name-list');
const rangeNameToggle = document.getElementById('range-name-toggle');
const rangeInputsContainer = document.getElementById('range-inputs-container');
const largePreviewImg = document.getElementById('large-preview-img');
const largePreviewContainer = document.getElementById('large-preview-container');
const previewPlaceholder = document.getElementById('preview-placeholder');
const smartSelectToggle = document.getElementById('smart-select-toggle');
const gridToggleBtn = document.getElementById('grid-toggle-btn');
const captureBtn = document.getElementById('capture-btn');
const rotateLeftBtn = document.getElementById('rotate-left-btn');
const rotateRightBtn = document.getElementById('rotate-right-btn');
const pageWrapper = document.getElementById('page-wrapper');
const pageBody = document.getElementById('page-body');
const previewNameInput = document.getElementById('preview-name-input');
const highlightTallBtn = document.getElementById('highlight-tall-btn');
const flipHorizontalBtn = document.getElementById('flip-horizontal-btn');
const flipVerticalBtn = document.getElementById('flip-vertical-btn');
const togglePreviewBtn = document.getElementById('toggle-preview-btn');
const numericFilterBtn = document.getElementById('numeric-filter-btn');
const numericModeControls = document.getElementById('numeric-mode-controls');
const numericNameSuggestions = document.getElementById('numeric-name-suggestions');
const applyNumericSuggestionsBtn = document.getElementById('apply-numeric-suggestions-btn');
const downloadNumericBtn = document.getElementById('download-numeric-btn');
const suggestionButtonsContainer = document.getElementById('suggestion-buttons-container');
const suggestionButtons = document.getElementById('suggestion-buttons');
const numericFilteredNamesList = document.getElementById('numeric-filtered-names-list');
const suggestionCountSelect = document.getElementById('suggestion-count-select');
const fineGrainedSuggestionsContainer = document.getElementById('fine-grained-suggestions');
const toolbar = document.getElementById('toolbar');
const pinToolbarBtn = document.getElementById('pin-toolbar-btn');
const localNoteArea = document.getElementById('local-note-area');
const hotkeySettingsContainer = document.getElementById('hotkey-settings');
const deleteSelectedBtn = document.getElementById('delete-selected-btn');
const applySingleNameToggle = document.getElementById('apply-single-name-toggle');
const nextImageBtn = document.getElementById('next-image-btn');
const prevImageBtn = document.getElementById('prev-image-btn');
const hideAllImagesBtn = document.getElementById('hide-all-images-btn');
const progressOverlay = document.getElementById('progress-overlay');
const progressText = document.getElementById('progress-text');
const uploadProgress = document.getElementById('upload-progress');
const downloadProgress = document.getElementById('download-progress');
const voiceInputBtn = document.getElementById('voice-input-btn');
const toggleSmartGridBtn = document.getElementById('toggle-smart-grid-btn');
const smartGridPanel = document.getElementById('smart-grid-panel');
const textReplacementRulesEl = document.getElementById('text-replacement-rules');

let recognition = null;
let isRecognizing = false;
let lastFocusedInputForVoice = null;

let photoGrid = document.getElementById('photo-grid-main');
let sortableInstance = null;
let photoIdCounter = 0;
const photoDataMap = new Map();
let history = [];
let currentState = null;
let lastSelectedWrapper = null;
let lastFocusedInput = null;
let isDownloading = false;
let draggedItems = [];
let imgScale = 1;
let imgTranslate = { x: 0, y: 0 };
let isPanning = false;
let startPan = { x: 0, y: 0 };

let hotkeys = {
    nextImage: 'CapsLock',
    prevImage: 'Shift',
    editName: 'F2',
    rotateLeft: 'ArrowLeft',
    rotateRight: 'ArrowRight',
    pinToolbar: 'KeyP',
    voiceInput: 'Backquote',
    translateName: 'KeyT',
    smartGridVoice: 'Backquote', 
    smartGridPrev: 'Shift+Tab', 
    smartGridNext: 'Tab'
};

// --- C√°c h√†m ti·ªán √≠ch (S·∫Øp x·∫øp ·∫£nh) ---
function removeLeadingOrderPrefix(filename) { return filename.replace(/^\d+\.\s+/, ''); }
function getMimeTypeFromName(name, originalType) { if (!name) return originalType; const lowerName = name.toLowerCase(); if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg')) return 'image/jpeg'; if (lowerName.endsWith('.png')) return 'image/png'; if (lowerName.endsWith('.gif')) return 'image/gif'; if (lowerName.endsWith('.webp')) return 'image/webp'; if (lowerName.endsWith('.bmp')) return 'image/bmp'; return originalType; }
function syncInputAttributes() { mainContentEl.querySelectorAll('input[type="text"]').forEach(input => input.setAttribute('value', input.value)); mainContentEl.querySelectorAll('textarea').forEach(textarea => textarea.textContent = textarea.value); mainContentEl.querySelectorAll('input[type="checkbox"]').forEach(input => { if (input.checked) input.setAttribute('checked', 'checked'); else input.removeAttribute('checked'); }); }
function saveState() { syncInputAttributes(); const stateHTML = mainContentEl.innerHTML; if (stateHTML !== currentState) { if (currentState !== null) history.push(currentState); if (history.length > 50) history.shift(); currentState = stateHTML; } }
function updateCurrentState() { syncInputAttributes(); currentState = mainContentEl.innerHTML; }
function restoreStateFromHistory() { if (history.length > 0) { const stateToRestore = history.pop(); mainContentEl.innerHTML = stateToRestore; currentState = stateToRestore; reInitializeApp(); } else { alert('Kh√¥ng c√≥ h√†nh ƒë·ªông n√†o ƒë·ªÉ ho√†n t√°c.'); } }
function processImageRotation(file) { return new Promise((resolve) => { resolve(file); }); }
async function transformCurrentImage(transformParams) { if (!lastSelectedWrapper) return; const id = lastSelectedWrapper.getAttribute('data-photo-id'); if (!id || !photoDataMap.has(id)) return; saveState(); const { blob } = photoDataMap.get(id); const bitmap = await createImageBitmap(blob); const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); const { degrees = 0, flipH = false, flipV = false } = transformParams; if (Math.abs(degrees) === 90) { canvas.width = bitmap.height; canvas.height = bitmap.width; } else { canvas.width = bitmap.width; canvas.height = bitmap.height; } ctx.translate(canvas.width / 2, canvas.height / 2); if (degrees) ctx.rotate(degrees * Math.PI / 180); ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1); ctx.drawImage(bitmap, -bitmap.width / 2, -bitmap.height / 2); canvas.toBlob((newBlob) => { if (!newBlob) return; photoDataMap.set(id, { ...photoDataMap.get(id), blob: newBlob }); const newUrl = URL.createObjectURL(newBlob); lastSelectedWrapper.querySelector('.photo-item').src = newUrl; largePreviewImg.src = newUrl; largePreviewImg.setAttribute('data-current-src', newUrl); resetZoom(); updateCurrentState(); }, blob.type || 'image/jpeg', 0.95); }
function resetZoom() { imgScale = 1; imgTranslate = { x: 0, y: 0 }; updateTransform(); }
function updateTransform() { largePreviewImg.style.transform = `translate(${imgTranslate.x}px, ${imgTranslate.y}px) scale(${imgScale})`; }
function showFineGrainedSuggestions(baseText) { fineGrainedSuggestionsContainer.innerHTML = ''; const match = baseText.match(/(-?\d+\.?\d*)/); if (!match) return; const num = parseFloat(match[0]); if (isNaN(num)) return; const unit = baseText.substring(match[0].length).trim(); const parts = match[0].split('.'); const precision = parts.length > 1 ? parts[1].length : 0; const step = Math.pow(10, -precision); const fragment = document.createDocumentFragment(); for(let i = -3; i <= 3; i++) { if (i === 0) continue; const newNum = (num + i * step).toFixed(precision); const btn = document.createElement('button'); btn.textContent = `${newNum}${unit}`; btn.onclick = () => { if(lastSelectedWrapper) { const nameInput = lastSelectedWrapper.querySelector('.name-container input[type="text"]'); const currentPrefix = nameInput.value.match(/^\d+\.\s+/); const newName = (currentPrefix ? currentPrefix[0] : '') + btn.textContent; nameInput.value = newName; previewNameInput.value = newName; syncNameListFromInputs(); updateSuggestionButtons(lastSelectedWrapper); saveState(); updateCurrentState(); } }; fragment.appendChild(btn); } fineGrainedSuggestionsContainer.appendChild(fragment); }
function updateSuggestionButtons(wrapper) { fineGrainedSuggestionsContainer.innerHTML = ''; if (pageBody.classList.contains('numeric-mode') && wrapper && wrapper.dataset.suggestions) { suggestionButtons.innerHTML = ''; const suggestions = JSON.parse(wrapper.dataset.suggestions); const nameInput = wrapper.querySelector('.name-container input[type="text"]'); const currentNameWithoutPrefix = removeLeadingOrderPrefix(nameInput.value); suggestions.forEach(suggestionText => { if (suggestionText) { const btn = document.createElement('button'); btn.textContent = suggestionText; btn.title = `Ch·ªçn "${suggestionText}" l√†m t√™n ch√≠nh th·ª©c`; if (suggestionText === currentNameWithoutPrefix) { btn.classList.add('suggestion-selected'); } btn.onclick = () => { const currentPrefix = nameInput.value.match(/^\d+\.\s+/); const newName = (currentPrefix ? currentPrefix[0] : '') + suggestionText; nameInput.value = newName; previewNameInput.value = newName; suggestionButtons.querySelectorAll('button').forEach(b => b.classList.remove('suggestion-selected')); btn.classList.add('suggestion-selected'); syncNameListFromInputs(); saveState(); updateCurrentState(); }; btn.addEventListener('focus', () => showFineGrainedSuggestions(suggestionText)); suggestionButtons.appendChild(btn); } }); suggestionButtonsContainer.style.display = suggestionButtons.children.length > 0 ? 'block' : 'none'; } else { suggestionButtonsContainer.style.display = 'none'; } }
function updatePreview(wrapper) { const selectedWrappers = photoGrid.querySelectorAll('.photo-wrapper.selected-photo'); if (selectedWrappers.length === 1) { const singleWrapper = selectedWrappers[0]; const id = singleWrapper.getAttribute('data-photo-id'); if (id && photoDataMap.has(id)) { const data = photoDataMap.get(id); const imgSrc = URL.createObjectURL(data.blob); const oldSrc = largePreviewImg.getAttribute('data-current-src'); if (oldSrc && oldSrc.startsWith('blob:')) { URL.revokeObjectURL(oldSrc); } largePreviewImg.src = imgSrc; largePreviewImg.alt = singleWrapper.querySelector('input[type="text"]').value; largePreviewImg.setAttribute('data-current-src', imgSrc); resetZoom(); previewPlaceholder.style.display = 'none'; largePreviewImg.style.display = 'block'; previewNameInput.value = singleWrapper.querySelector('input[type="text"]').value; previewNameInput.style.display = 'block'; updateSuggestionButtons(singleWrapper); } else { largePreviewImg.src = ""; largePreviewImg.alt = ""; largePreviewImg.removeAttribute('data-current-src'); largePreviewImg.style.display = 'none'; previewPlaceholder.style.display = 'block'; previewPlaceholder.textContent = "L·ªói: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ·∫£nh."; previewNameInput.value = ''; previewNameInput.style.display = 'none'; suggestionButtonsContainer.style.display = 'none'; fineGrainedSuggestionsContainer.innerHTML = ''; } } else { largePreviewImg.src = ""; largePreviewImg.alt = ""; largePreviewImg.removeAttribute('data-current-src'); largePreviewImg.style.display = 'none'; previewPlaceholder.style.display = 'block'; previewPlaceholder.textContent = "Ch·ªçn ·∫£nh ƒë·ªÉ xem. LƒÉn chu·ªôt ƒë·ªÉ Zoom, Gi·ªØ chu·ªôt tr√°i ƒë·ªÉ K√©o."; previewNameInput.value = ''; previewNameInput.style.display = 'none'; suggestionButtonsContainer.style.display = 'none'; fineGrainedSuggestionsContainer.innerHTML = ''; } }
function createPhotoElement(id, processedBlob, originalName, fileSize) { const wrapper = document.createElement('div'); wrapper.className = 'photo-wrapper newly-added'; wrapper.setAttribute('data-photo-id', id); if (fileSize && fileSize < 40000) { wrapper.classList.add('is-small'); } const imgContainer = document.createElement('div'); imgContainer.className = 'img-container'; const img = document.createElement('img'); img.className = 'photo-item'; img.src = URL.createObjectURL(processedBlob); img.draggable = false; const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.title = 'X√≥a ·∫£nh n√†y'; const excludeBtn = document.createElement('button'); excludeBtn.className = 'exclude-numeric-btn'; excludeBtn.innerHTML = '&#10007;'; excludeBtn.title = 'Lo·∫°i tr·ª´ kh·ªèi ch·∫ø ƒë·ªô xem s·ªë li·ªáu'; const replaceBtn = document.createElement('button'); replaceBtn.className = 'replace-btn'; replaceBtn.innerHTML = '&#8635;'; replaceBtn.title = 'Thay th·∫ø ·∫£nh'; const replacePanel = document.createElement('div'); replacePanel.className = 'replace-panel'; replacePanel.innerHTML = `<button class="replace-from-file-btn" title="Thay th·∫ø b·∫±ng ·∫£nh t·ª´ m·ªôt file">T·ª´ File</button><button class="replace-from-clipboard-btn" title="Thay th·∫ø b·∫±ng ·∫£nh ƒëang c√≥ trong clipboard">T·ª´ Clipboard</button>`; const nameContainer = document.createElement('div'); nameContainer.className = 'name-container'; const nameInput = document.createElement('input'); nameInput.type = 'text'; const nameWithoutExtension = originalName.replace(/\.[^/.]+$/, ""); nameInput.value = nameWithoutExtension; imgContainer.appendChild(img); imgContainer.appendChild(deleteBtn); imgContainer.appendChild(excludeBtn); imgContainer.appendChild(replaceBtn); nameContainer.appendChild(nameInput); wrapper.appendChild(imgContainer); wrapper.appendChild(replacePanel); wrapper.appendChild(nameContainer); photoDataMap.set(id, { blob: processedBlob, originalName: originalName }); setTimeout(() => wrapper.classList.remove('newly-added'), 1500); return wrapper; }
function syncNameListFromInputs() { const allNameInputs = photoGrid.querySelectorAll('.name-container input[type="text"]'); const namesArray = Array.from(allNameInputs).map(input => removeLeadingOrderPrefix(input.value.trim())); nameListTextArea.value = namesArray.join('\n'); }
function updateNumberingAndSync() { const wrappers = photoGrid.querySelectorAll('.photo-wrapper'); wrappers.forEach((wrapper, index) => { const nameInput = wrapper.querySelector('.name-container input[type="text"]'); if (nameInput) { const currentName = removeLeadingOrderPrefix(nameInput.value); nameInput.value = `${index + 1}. ${currentName}`; } }); syncNameListFromInputs(); }
async function processAndDisplayFiles(filesArray) { if (filesArray.length === 0) return; saveState(); progressOverlay.style.display = 'flex'; uploadProgress.style.display = 'block'; downloadProgress.style.display = 'none'; progressText.textContent = `ƒêang t·∫£i ${filesArray.length} ·∫£nh...`; uploadProgress.value = 0; uploadProgress.max = filesArray.length; const selectedWrappers = photoGrid.querySelectorAll('.photo-wrapper.selected-photo'); const insertionPoint = selectedWrappers.length === 1 ? selectedWrappers[0] : null; const fragment = document.createDocumentFragment(); let lastAddedElement = null; for (let i = 0; i < filesArray.length; i++) { const file = filesArray[i]; if (!file || (!file.type.startsWith('image/') && file.type !== 'application/octet-stream')) { uploadProgress.value = i + 1; continue; }; try { let processedBlob = await processImageRotation(file); const originalName = file.name || `image_${Date.now()}.jpg`; if (processedBlob.type === 'application/octet-stream') { const correctedType = getMimeTypeFromName(originalName, processedBlob.type); if (correctedType !== processedBlob.type) { processedBlob = new Blob([processedBlob], { type: correctedType }); } } const id = `photo-${photoIdCounter++}`; const wrapper = createPhotoElement(id, processedBlob, originalName, file.size); fragment.appendChild(wrapper); lastAddedElement = wrapper; } catch (error) { console.error("L·ªói x·ª≠ l√Ω ·∫£nh:", error); } uploadProgress.value = i + 1; } if (insertionPoint) { insertionPoint.after(fragment); } else { photoGrid.appendChild(fragment); } updateNumberingAndSync(); if (lastAddedElement) { document.querySelectorAll('.selected-photo').forEach(el => el.classList.remove('selected-photo')); lastAddedElement.classList.add('selected-photo'); lastSelectedWrapper = lastAddedElement; lastAddedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); updatePreview(lastAddedElement); } updateCurrentState(); setTimeout(() => { progressOverlay.style.display = 'none'; uploadProgress.value = 0; }, 500); }
async function handleFiles(files) { const imageFiles = []; const zipFiles = []; for (const file of files) { if (file.type.startsWith('image/') || file.type === 'application/octet-stream') { imageFiles.push(file); } else if (file.name.toLowerCase().endsWith('.zip')) { zipFiles.push(file); } } if (imageFiles.length > 0) { await processAndDisplayFiles(imageFiles); } for (const zipFile of zipFiles) { await handleZipFile(zipFile); } }
async function handleZipFile(file) { try { progressOverlay.style.display = 'flex'; progressText.textContent = `ƒêang gi·∫£i n√©n file ${file.name}...`; uploadProgress.value = 0; const zip = await JSZip.loadAsync(file); const imagePromises = []; const imageEntries = []; zip.forEach((relativePath, zipEntry) => { const isImage = /\.(jpe?g|png|gif|webp|bmp)$/i.test(zipEntry.name); const isHiddenFile = zipEntry.name.startsWith('__MACOSX/') || zipEntry.name.includes('/.'); if (!zipEntry.dir && isImage && !isHiddenFile) { imageEntries.push(zipEntry); } }); uploadProgress.max = imageEntries.length; progressText.textContent = `ƒêang tr√≠ch xu·∫•t ${imageEntries.length} ·∫£nh t·ª´ ${file.name}...`; for (let i = 0; i < imageEntries.length; i++) { const zipEntry = imageEntries[i]; const promise = zipEntry.async('blob').then(blob => { const correctedType = getMimeTypeFromName(zipEntry.name, blob.type); const file = new File([blob], zipEntry.name, { type: correctedType }); return file; }); imagePromises.push(promise); uploadProgress.value = i + 1; } const extractedFiles = await Promise.all(imagePromises); await processAndDisplayFiles(extractedFiles); } catch (error) { console.error("L·ªói khi x·ª≠ l√Ω file ZIP:", error); alert("ƒê√£ c√≥ l·ªói x·∫£y ra khi gi·∫£i n√©n file ZIP. Vui l√≤ng ki·ªÉm tra console."); progressOverlay.style.display = 'none'; } }
function generateZip(elementsToZip, zipName = 'photos.zip') { if (isDownloading) return alert('Qu√° tr√¨nh t·∫£i xu·ªëng ƒëang di·ªÖn ra.'); if (elementsToZip.length === 0) return alert('Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ t·∫£i xu·ªëng.'); isDownloading = true; progressOverlay.style.display = 'flex'; downloadProgress.style.display = 'block'; uploadProgress.style.display = 'none'; progressText.textContent = 'ƒêang n√©n file...'; downloadProgress.value = 0; const zip = new JSZip(); elementsToZip.forEach(wrapper => { const id = wrapper.getAttribute('data-photo-id'); const nameInput = wrapper.querySelector('.name-container input[type="text"]'); if (id && photoDataMap.has(id)) { const { blob } = photoDataMap.get(id); const fullFileName = nameInput.value.trim() || `image_${id}`; const extension = blob.type.split('/')[1] || 'jpg'; const finalZipName = `${fullFileName.replace(/[<>:"/\\|?*]+/g, '_')}.${extension}`; zip.file(finalZipName, blob); } }); zip.generateAsync({ type: "blob" }, (metadata) => { downloadProgress.value = metadata.percent; progressText.textContent = `ƒêang n√©n file... ${metadata.percent.toFixed(0)}%`; }) .then((content) => saveAs(content, zipName)) .catch(err => { console.error("L·ªói:", err); alert("L·ªói khi t·∫°o file ZIP."); }) .finally(() => { setTimeout(() => { progressOverlay.style.display = 'none'; }, 1000); isDownloading = false; reInitializeApp(); }); }
function initializeSortable(isDraggable) { if (sortableInstance) sortableInstance.destroy(); if (photoGrid) { sortableInstance = new Sortable(photoGrid, { group: 'shared-photos', animation: 150, ghostClass: 'ghost-class', dragClass: 'drag-class', draggable: '.photo-wrapper', sort: isDraggable, onStart: function(evt) { const allSelected = Array.from(photoGrid.querySelectorAll('.selected-photo')); if (!evt.item.classList.contains('selected-photo')) { draggedItems = []; } else { draggedItems = allSelected.filter(item => item !== evt.item); } draggedItems.forEach(item => item.style.display = 'none'); }, onEnd: function(evt) { draggedItems.forEach(item => item.style.display = ''); let referenceNode = evt.item; draggedItems.forEach(item => { referenceNode.parentNode.insertBefore(item, referenceNode.nextSibling); referenceNode = item; }); draggedItems = []; saveState(); updateNumberingAndSync(); updateCurrentState(); }, }); } }
function reInitializeApp() { photoGrid = document.getElementById('photo-grid-main'); photoGrid.querySelectorAll('.photo-item').forEach(img => { if (img.src && img.src.startsWith('blob:')) { URL.revokeObjectURL(img.src); } }); photoGrid.querySelectorAll('.photo-wrapper').forEach(wrapper => { const id = wrapper.getAttribute('data-photo-id'); const img = wrapper.querySelector('.photo-item'); if (id && img && photoDataMap.has(id)) { const data = photoDataMap.get(id); if(data && data.blob) { img.src = URL.createObjectURL(data.blob); } } }); gridToggleBtn.textContent = photoGrid.classList.contains('dense-mode') ? 'L∆∞·ªõi th∆∞·ªùng' : 'L∆∞·ªõi x2'; document.getElementById('lock-toggle').checked = false; initializeSortable(true); const selectedEl = photoGrid.querySelector('.selected-photo'); lastSelectedWrapper = selectedEl || null; updatePreview(lastSelectedWrapper); syncNameListFromInputs(); }
function navigateImage(direction) { const visibleWrappers = Array.from(photoGrid.querySelectorAll('.photo-wrapper:not(.hidden-by-filter)')); if (visibleWrappers.length === 0) return; const currentSelected = photoGrid.querySelector('.photo-wrapper.selected-photo'); let currentIndex = -1; if (currentSelected) { currentIndex = visibleWrappers.indexOf(currentSelected); } let nextIndex; if (direction === 'next') { nextIndex = (currentIndex + 1) % visibleWrappers.length; } else { nextIndex = (currentIndex - 1 + visibleWrappers.length) % visibleWrappers.length; } const nextWrapper = visibleWrappers[nextIndex]; if (nextWrapper) { if (currentSelected) currentSelected.classList.remove('selected-photo'); nextWrapper.classList.add('selected-photo'); lastSelectedWrapper = nextWrapper; updatePreview(lastSelectedWrapper); nextWrapper.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } }
function saveHotkeys() { localStorage.setItem('photoSorterHotkeys', JSON.stringify(hotkeys)); }
function loadHotkeys() { const savedHotkeys = localStorage.getItem('photoSorterHotkeys'); if (savedHotkeys) { try { const parsed = JSON.parse(savedHotkeys); hotkeys = {...hotkeys, ...parsed }; } catch(e) { console.error("Could not parse saved hotkeys", e); } } for (const action in hotkeys) { const input = document.querySelector(`#hotkey-settings input[data-action="${action}"]`); if (input) { input.value = hotkeys[action]; } } }
function setToolbarPinned(isPinned) { pageWrapper.classList.toggle('toolbar-pinned', isPinned); toolbar.classList.toggle('visible', isPinned); localStorage.setItem('toolbarPinned', isPinned); pinToolbarBtn.textContent = isPinned ? 'üìå' : '‚Üí'; if(isPinned) { pinToolbarBtn.title = 'B·ªè ghim thanh c√¥ng c·ª•'; } else { pinToolbarBtn.title = 'Ghim thanh c√¥ng c·ª•'; } }
async function translateFocusedInput() { const activeInput = document.activeElement; if (!activeInput || !activeInput.matches('.name-container input[type="text"], #preview-name-input')) { alert('Vui l√≤ng ch·ªçn m·ªôt √¥ t√™n ·∫£nh ƒë·ªÉ d·ªãch.'); return; } const originalValue = activeInput.value; const partsRegex = /^(\d+\.\s*)(.*?)([\s\d.,]+[a-zA-Z%¬∞]*)?$/; const match = originalValue.match(partsRegex); let prefix = ''; let textToTranslate = ''; let suffix = ''; if (match) { prefix = match[1] || ''; textToTranslate = match[2] || ''; suffix = match[3] || ''; } else { const simplePrefixMatch = originalValue.match(/^(\d+\.\s*)/); if (simplePrefixMatch) { prefix = simplePrefixMatch[0]; textToTranslate = originalValue.substring(prefix.length); } else { textToTranslate = originalValue; } } if (!textToTranslate.trim()) { alert('Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ d·ªãch.'); return; } const sourceLang = 'vi'; const targetLang = 'en'; const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodeURIComponent(textToTranslate)}`; activeInput.value = 'ƒêang d·ªãch...'; activeInput.disabled = true; try { const response = await fetch(url); if (!response.ok) { throw new Error('L·ªói m·∫°ng khi d·ªãch.'); } const data = await response.json(); const translatedText = data?.[0]?.[0]?.[0]; if (translatedText) { const finalValue = `${prefix}${translatedText}${suffix}`.replace(/\s+/g, ' ').trim(); activeInput.value = finalValue; activeInput.dispatchEvent(new Event('input', { bubbles: true })); } else { throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c k·∫øt qu·∫£ d·ªãch h·ª£p l·ªá.'); } } catch (error) { console.error('L·ªói d·ªãch:', error); alert('ƒê√£ x·∫£y ra l·ªói khi d·ªãch. Vui l√≤ng th·ª≠ l·∫°i.'); activeInput.value = originalValue; } finally { activeInput.disabled = false; activeInput.focus(); } }
function getTextReplacementRules() { const rulesText = textReplacementRulesEl.value; if (!rulesText) return []; return rulesText.trim().split('\n').map(line => { const parts = line.split(','); if (parts.length < 2) return null; return { from: parts[0].trim(), to: parts.slice(1).join(',').trim() }; }).filter(Boolean); }
function applyTextReplacements(text) { const rules = getTextReplacementRules(); let processedText = ` ${text} `; rules.forEach(rule => { const regex = new RegExp(`\\s${rule.from}\\s`, 'gi'); processedText = processedText.replace(regex, ` ${rule.to} `); }); return processedText.trim().replace(/\s+/g, ' '); }
function initializeSpeechRecognition() { const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; if (!SpeechRecognition) { console.warn("Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ Web Speech API."); voiceInputBtn.disabled = true; voiceInputBtn.title = "Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng n√†y."; const voiceHotkeyInput = document.getElementById('hotkey-voice-input'); if(voiceHotkeyInput) voiceHotkeyInput.disabled = true; return; } recognition = new SpeechRecognition(); recognition.continuous = false; recognition.lang = 'vi-VN'; recognition.interimResults = false; recognition.maxAlternatives = 1; recognition.onstart = () => { isRecognizing = true; voiceInputBtn.textContent = 'üî¥'; voiceInputBtn.style.backgroundColor = '#dc3545'; voiceInputBtn.title = 'ƒêang l·∫Øng nghe...'; }; recognition.onresult = (event) => { const rawTranscript = event.results[0][0].transcript; const processedTranscript = applyTextReplacements(rawTranscript); if (lastFocusedInputForVoice && processedTranscript) { const target = lastFocusedInputForVoice; const start = target.selectionStart; const end = target.selectionEnd; const currentValue = target.value; const newValue = currentValue.substring(0, start) + processedTranscript + currentValue.substring(end); target.value = newValue; const newCursorPos = start + processedTranscript.length; target.setSelectionRange(newCursorPos, newCursorPos); target.dispatchEvent(new Event('input', { bubbles: true })); target.focus(); } }; recognition.onspeechend = () => { recognition.stop(); }; recognition.onend = () => { isRecognizing = false; voiceInputBtn.textContent = 'üé§'; voiceInputBtn.style.backgroundColor = ''; voiceInputBtn.title = 'K√≠ch ho·∫°t nh·∫≠p li·ªáu gi·ªçng n√≥i (d√πng ph√≠m t·∫Øt)'; }; recognition.onerror = (event) => { console.error('L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i:', event.error); if (event.error === 'not-allowed' || event.error === 'service-not-allowed') { alert('Quy·ªÅn truy c·∫≠p micro ƒë√£ b·ªã t·ª´ ch·ªëi. Vui l√≤ng c·∫•p quy·ªÅn trong c√†i ƒë·∫∑t tr√¨nh duy·ªát v√† s·ª≠ d·ª•ng trang web qua HTTPS.'); } }; }
function startVoiceRecognition() { if (!recognition || isRecognizing) { return; } if (document.activeElement && (document.activeElement.matches('input[type="text"]') || document.activeElement.tagName === 'TEXTAREA')) { lastFocusedInputForVoice = document.activeElement; recognition.start(); } else { alert('Vui l√≤ng ch·ªçn m·ªôt √¥ nh·∫≠p t√™n ho·∫∑c √¥ ghi ch√∫ ƒë·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠p li·ªáu b·∫±ng gi·ªçng n√≥i.'); } }

// --- LOGIC CHO B·∫¢NG T√çNH TH√îNG MINH (Smart Grid) ---
const smartGrid = (() => {
    // DOM Elements
    const rowsInput = document.getElementById('sg-rows');
    const colsInput = document.getElementById('sg-cols');
    const createGridBtn = document.getElementById('sg-create-grid');
    const gridContainer = document.getElementById('grid-container');
    const micButton = document.getElementById('mic-button');
    const undoBtn = document.getElementById('sg-undo-btn');
    const redoBtn = document.getElementById('sg-redo-btn');
    const floatBtn = document.getElementById('sg-float-btn');
    const prevClusterBtn = document.getElementById('sg-prev-cluster-btn');
    const nextClusterBtn = document.getElementById('sg-next-cluster-btn');
    // Y√äU C·∫¶U 2: L·∫•y c√°c element cho ch·∫ø ƒë·ªô g∆∞∆°ng
    const mirrorBtn = document.getElementById('sg-mirror-btn');
    const opacitySlider = document.getElementById('sg-opacity-slider');
    const opacityLabel = document.querySelector('label[for="sg-opacity-slider"]');

    // State
    let grid, startCell = null, isSelecting = false;
    let history = [];
    let historyIndex = -1;
    let dataClusters = [];
    let currentClusterIndex = -1;
    let recognition;
    let isDraggingPanel = false;
    let panelOffsetX, panelOffsetY;

    function saveState() {
        if (!grid) return;
        const gridData = Array.from(grid.querySelectorAll('tbody tr')).map(row =>
            Array.from(row.querySelectorAll('td')).map(cell => cell.innerHTML)
        );
        history = history.slice(0, historyIndex + 1);
        history.push(gridData);
        historyIndex++;
        updateUndoRedoButtons();
    }

    function restoreState(index) {
        if (!grid || index < 0 || index >= history.length) return;
        const gridData = history[index];
        grid.querySelectorAll('tbody tr').forEach((row, i) => {
            row.querySelectorAll('td').forEach((cell, j) => {
                cell.innerHTML = gridData[i][j];
            });
        });
        findAllClusters();
        grid.querySelectorAll('thead th[data-col]').forEach(th => {
            if (th.classList.contains('locked-col')) {
                toggleColumnLock(th, true, true); 
            }
        });
    }

    function undo() { if (historyIndex > 0) { historyIndex--; restoreState(historyIndex); updateUndoRedoButtons(); } }
    function redo() { if (historyIndex < history.length - 1) { historyIndex++; restoreState(historyIndex); updateUndoRedoButtons(); } }
    
    function updateUndoRedoButtons() {
        undoBtn.disabled = historyIndex <= 0;
        redoBtn.disabled = historyIndex >= history.length - 1;
    }

    function createGrid() {
        const rows = parseInt(rowsInput.value, 10);
        const cols = parseInt(colsInput.value, 10);
        let tableHtml = '<table><thead><tr><th></th>';
        for (let j = 0; j < cols; j++) {
            tableHtml += `<th data-col="${j}">${String.fromCharCode(65 + j)}<span class="lock-btn" title="Kh√≥a/M·ªü kh√≥a c·ªôt">üîì</span></th>`;
        }
        tableHtml += '</tr></thead><tbody>';
        for (let i = 0; i < rows; i++) {
            tableHtml += `<tr><th>${i + 1}</th>`;
            for (let j = 0; j < cols; j++) tableHtml += `<td contenteditable="true" data-row="${i}" data-col="${j}"></td>`;
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        gridContainer.innerHTML = tableHtml;
        grid = gridContainer.querySelector('table');
        grid.addEventListener('mousedown', handleMouseDown);
        grid.addEventListener('mouseover', handleMouseOver);
        document.addEventListener('mouseup', handleMouseUp);
        grid.addEventListener('paste', handlePaste);
        grid.addEventListener('input', handleInput);
        document.addEventListener('copy', handleCopy);
        // Y√äU C·∫¶U 1: Th√™m listener ƒë·ªÉ x·ª≠ l√Ω vi·ªác di chuy·ªÉn b·∫±ng ph√≠m m≈©i t√™n v√† kh√≥a focus
        grid.addEventListener('keydown', handleKeyDown);

        grid.querySelector('thead').addEventListener('click', (e) => {
            if (e.target.classList.contains('lock-btn')) {
                const th = e.target.closest('th');
                toggleColumnLock(th, !th.classList.contains('locked-col'));
            }
        });
        saveState();
        findAllClusters();
    }
    
    // Y√äU C·∫¶U 1: H√†m kh√≥a/m·ªü kh√≥a c·ªôt
    function toggleColumnLock(th, shouldLock, isRestoring = false) {
        const colIndex = th.dataset.col;
        if (colIndex === undefined) return;

        th.classList.toggle('locked-col', shouldLock);
        th.querySelector('.lock-btn').textContent = shouldLock ? 'üîí' : 'üîì';

        const cells = grid.querySelectorAll(`td[data-col="${colIndex}"]`);
        cells.forEach(cell => {
            cell.classList.toggle('locked-cell', shouldLock);
            // Quan tr·ªçng: set contenteditable th√†nh false ƒë·ªÉ v√¥ hi·ªáu h√≥a ho√†n to√†n
            cell.setAttribute('contenteditable', !shouldLock);
        });
        
        if (!isRestoring) {
            saveState();
        }
    }

    // Y√äU C·∫¶U 1: H√†m x·ª≠ l√Ω ph√≠m t·∫Øt ƒë·ªÉ ngƒÉn focus v√†o √¥ b·ªã kh√≥a
    function handleKeyDown(e) {
        // Ch·ªâ x·ª≠ l√Ω c√°c ph√≠m m≈©i t√™n
        if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
        
        const activeCell = document.activeElement.closest('td');
        if (!activeCell) return;

        e.preventDefault(); // NgƒÉn h√†nh vi m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát

        let { row, col } = activeCell.dataset;
        let currentRow = parseInt(row, 10);
        let currentCol = parseInt(col, 10);
        const maxRows = parseInt(rowsInput.value, 10) - 1;
        const maxCols = parseInt(colsInput.value, 10) - 1;

        let nextRow = currentRow;
        let nextCol = currentCol;

        // V√≤ng l·∫∑p ƒë·ªÉ t√¨m √¥ h·ª£p l·ªá ti·∫øp theo (kh√¥ng b·ªã kh√≥a)
        while (true) {
            if (e.key === 'ArrowUp') nextRow--;
            if (e.key === 'ArrowDown') nextRow++;
            if (e.key === 'ArrowLeft') nextCol--;
            if (e.key === 'ArrowRight') nextCol++;

            // D·ª´ng l·∫°i n·∫øu ƒëi ra kh·ªèi bi√™n c·ªßa b·∫£ng
            if (nextRow < 0 || nextRow > maxRows || nextCol < 0 || nextCol > maxCols) {
                return; 
            }

            const nextCell = grid.querySelector(`td[data-row="${nextRow}"][data-col="${nextCol}"]`);
            // N·∫øu t√¨m th·∫•y √¥ ti·∫øp theo v√† √¥ ƒë√≥ kh√¥ng b·ªã kh√≥a
            if (nextCell && !nextCell.classList.contains('locked-cell')) {
                nextCell.focus(); // Focus v√†o √¥ ƒë√≥
                
                // Di chuy·ªÉn con tr·ªè ƒë·∫øn cu·ªëi n·ªôi dung c·ªßa √¥
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(nextCell);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
                break; // Tho√°t kh·ªèi v√≤ng l·∫∑p
            }
        }
    }


    function getCursorPosition(element) { let position = 0; const selection = window.getSelection(); if (selection.rangeCount > 0) { const range = selection.getRangeAt(0); const preCaretRange = range.cloneRange(); preCaretRange.selectNodeContents(element); preCaretRange.setEnd(range.endContainer, range.endOffset); position = preCaretRange.toString().length; } return position; }
    function setCursorPosition(element, position) { let charCount = 0, targetNode = null, targetOffset = 0; function findNodeAndOffset(node) { if (node.nodeType === Node.TEXT_NODE) { const nextCharCount = charCount + node.length; if (position <= nextCharCount) { targetNode = node; targetOffset = position - charCount; return true; } charCount = nextCharCount; } else if (node.nodeType === Node.ELEMENT_NODE) { for (let i = 0; i < node.childNodes.length; i++) if (findNodeAndOffset(node.childNodes[i])) return true; } return false; } findNodeAndOffset(element); if (targetNode) { const range = document.createRange(); const sel = window.getSelection(); range.setStart(targetNode, Math.min(targetOffset, targetNode.length)); range.collapse(true); sel.removeAllRanges(); sel.addRange(range); } }
    
    function handleInput(e) { if (e.target.tagName === 'TD') { const cursorPosition = getCursorPosition(e.target); highlightNumbersInCell(e.target); setCursorPosition(e.target, cursorPosition); clearTimeout(e.target.debounce); e.target.debounce = setTimeout(() => { saveState(); findAllClusters(); }, 500); } }
    function highlightNumbersInText(text) { return text.replace(/(?<!<[^>]*?)(\b\d+(\.\d+)?\b)/g, '<span class="highlight-number">$1</span>'); }
    function highlightNumbersInCell(cell) { const text = cell.textContent || ''; cell.innerHTML = highlightNumbersInText(text); }
    function clearSelection() { grid.querySelectorAll('.selected').forEach(cell => cell.classList.remove('selected')); }
    
    function handleMouseDown(e) { 
        if (e.target.tagName === 'TD' && e.target.classList.contains('locked-cell')) {
            e.preventDefault();
            return;
        }
        if (e.target.tagName !== 'TD') return; 
        removeClusterFocus(); 
        isSelecting = true; 
        if (!e.shiftKey) { 
            clearSelection(); 
            startCell = e.target; 
        } 
        selectCells(startCell, e.target); 
    }

    function handleMouseOver(e) { if (isSelecting && e.target.tagName === 'TD' && !e.target.classList.contains('locked-cell')) selectCells(startCell, e.target); }
    function handleMouseUp() { isSelecting = false; }

    function selectCells(start, end) { clearSelection(); const startRow = Math.min(parseInt(start.dataset.row), parseInt(end.dataset.row)); const endRow = Math.max(parseInt(start.dataset.row), parseInt(end.dataset.row)); const startCol = Math.min(parseInt(start.dataset.col), parseInt(end.dataset.col)); const endCol = Math.max(parseInt(start.dataset.col), parseInt(end.dataset.col)); for (let i = startRow; i <= endRow; i++) for (let j = startCol; j <= endCol; j++) { const cell = grid.querySelector(`td[data-row="${i}"][data-col="${j}"]`); if (cell && !cell.classList.contains('locked-cell')) cell.classList.add('selected'); } }
    
    function handleCopy(e) { if (!document.activeElement.closest('#smart-grid-panel')) return; const selectedCells = grid.querySelectorAll('.selected'); if (selectedCells.length === 0) return; e.preventDefault(); const rows = {}; selectedCells.forEach(cell => { const r = cell.dataset.row; const c = cell.dataset.col; if (!rows[r]) rows[r] = {}; rows[r][c] = cell.textContent; }); const rowKeys = Object.keys(rows).sort((a, b) => a - b); const copyString = rowKeys.map(r => { const colKeys = Object.keys(rows[r]).sort((a, b) => a - b); return colKeys.map(c => rows[r][c]).join('\t'); }).join('\r\n'); e.clipboardData.setData('text/plain', copyString); }
    function handlePaste(e) { e.preventDefault(); const pasteData = (e.clipboardData || window.clipboardData).getData('text'); const dataRows = pasteData.split('\n').map(row => row.split('\t')); const activeCell = startCell || grid.querySelector('.selected'); if (!activeCell) return; const startRow = parseInt(activeCell.dataset.row); const startCol = parseInt(activeCell.dataset.col); dataRows.forEach((row, i) => { row.forEach((cellData, j) => { 
        const targetCell = grid.querySelector(`td[data-row="${startRow + i}"][data-col="${startCol + j}"]`); 
        if (targetCell && !targetCell.classList.contains('locked-cell')) { 
            targetCell.textContent = cellData.replace(/\r$/, ''); 
            highlightNumbersInCell(targetCell); 
        } 
    }); }); saveState(); findAllClusters(); }
    
    function findAllClusters() { dataClusters = []; const regex = /(\d+(\.\d+)?)/g; grid.querySelectorAll('td').forEach(cell => { const text = cell.textContent || ''; let match; while ((match = regex.exec(text)) !== null) { dataClusters.push({ cell, value: match[0], index: match.index }); } }); }
    function removeClusterFocus() { const focused = document.querySelector('.cluster-focus'); if (focused) { const parentCell = focused.closest('td'); if (parentCell) { const text = parentCell.textContent; parentCell.textContent = text; highlightNumbersInCell(parentCell); } } }

    // Y√äU C·∫¶U 1: C·∫≠p nh·∫≠t h√†m ƒë·ªÉ b·ªè qua c√°c √¥ b·ªã kh√≥a
    function focusNextCluster() {
        if (dataClusters.length === 0) return;
        removeClusterFocus();
        let attempts = 0; // NgƒÉn v√≤ng l·∫∑p v√¥ t·∫≠n n·∫øu t·∫•t c·∫£ ƒë·ªÅu b·ªã kh√≥a
        do {
            currentClusterIndex++;
            if (currentClusterIndex >= dataClusters.length) currentClusterIndex = 0;
            attempts++;
        } while (dataClusters[currentClusterIndex].cell.classList.contains('locked-cell') && attempts < dataClusters.length);

        if (attempts < dataClusters.length) {
            focusClusterByIndex(currentClusterIndex);
        }
    }

    // Y√äU C·∫¶U 1: C·∫≠p nh·∫≠t h√†m ƒë·ªÉ b·ªè qua c√°c √¥ b·ªã kh√≥a
    function focusPrevCluster() {
        if (dataClusters.length === 0) return;
        removeClusterFocus();
        let attempts = 0;
        do {
            currentClusterIndex--;
            if (currentClusterIndex < 0) currentClusterIndex = dataClusters.length - 1;
            attempts++;
        } while (dataClusters[currentClusterIndex].cell.classList.contains('locked-cell') && attempts < dataClusters.length);

        if (attempts < dataClusters.length) {
            focusClusterByIndex(currentClusterIndex);
        }
    }

    function focusClusterByIndex(index) {
        const cluster = dataClusters[index];
        const cell = cluster.cell;
        // B·ªè qua n·∫øu √¥ b·ªã kh√≥a (ki·ªÉm tra d·ª± ph√≤ng)
        if (cell.classList.contains('locked-cell')) {
            return;
        }
        const text = cell.textContent || ''; const before = text.substring(0, cluster.index); const inside = `<span class="cluster-focus">${cluster.value}</span>`; const after = text.substring(cluster.index + cluster.value.length); cell.innerHTML = highlightNumbersInText(before) + inside + highlightNumbersInText(after); cell.querySelector('.cluster-focus')?.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
    }

    function setupSpeechRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) { micButton.disabled = true; return; }
        recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.lang = 'vi-VN';
        recognition.interimResults = true;
        recognition.onstart = () => { micButton.classList.add('recording'); micButton.textContent = 'üî¥'; };
        recognition.onend = () => { micButton.classList.remove('recording'); micButton.textContent = 'üé§'; };
        let finalTranscript = '';
        recognition.onresult = (event) => { let interimTranscript = ''; for (let i = event.resultIndex; i < event.results.length; ++i) { if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript; else interimTranscript += event.results[i][0].transcript; } if (event.results[event.results.length - 1].isFinal) {
             const resultText = applyTextReplacements(finalTranscript.trim()); 
             if (resultText) { updateCellWithVoiceData(resultText); } finalTranscript = ''; } };
        recognition.onerror = (event) => console.error('L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i (B·∫£ng t√≠nh): ', event.error);
    }

    function toggleVoiceRecognition() { if (!recognition) return; if (micButton.classList.contains('recording')) recognition.stop(); else recognition.start(); }
    function updateCellWithVoiceData(data) { const focusedCluster = document.querySelector('.cluster-focus'); if (focusedCluster) { const parentCell = focusedCluster.closest('td'); if (parentCell.classList.contains('locked-cell')) return; const oldHTML = parentCell.innerHTML; const newHTML = oldHTML.replace(focusedCluster.outerHTML, String(data)); parentCell.innerHTML = newHTML; highlightNumbersInCell(parentCell); } else { const selectedCells = grid.querySelectorAll('.selected'); if (selectedCells.length > 0) { selectedCells.forEach(cell => { if (!cell.classList.contains('locked-cell')) { cell.textContent = data; highlightNumbersInCell(cell); }}); } } saveState(); findAllClusters(); }
    
    // Y√äU C·∫¶U 2: C√°c h√†m ƒëi·ªÅu khi·ªÉn ch·∫ø ƒë·ªô g∆∞∆°ng v√† panel n·ªïi
    function toggleFloatingPanel() {
        const wasMirror = smartGridPanel.classList.contains('mirror-mode');
        smartGridPanel.classList.toggle('floating');
        if (!smartGridPanel.classList.contains('floating')) {
            smartGridPanel.style.top = ''; smartGridPanel.style.left = ''; smartGridPanel.style.width = ''; smartGridPanel.style.height = '';
            if (wasMirror) { // T·∫Øt ch·∫ø ƒë·ªô g∆∞∆°ng n·∫øu kh√¥ng c√≤n n·ªïi
                smartGridPanel.classList.remove('mirror-mode');
                opacitySlider.style.display = 'none';
                opacityLabel.style.display = 'none';
                localStorage.setItem('sgMirrorMode', 'false');
            }
        }
    }

    function toggleMirrorMode() {
        if (!smartGridPanel.classList.contains('floating')) {
            alert('Ch·∫ø ƒë·ªô G∆∞∆°ng ch·ªâ ho·∫°t ƒë·ªông khi b·∫£ng t√≠nh ƒëang ·ªü ch·∫ø ƒë·ªô n·ªïi.');
            return;
        }
        const isActive = smartGridPanel.classList.toggle('mirror-mode');
        opacitySlider.style.display = isActive ? 'inline-block' : 'none';
        opacityLabel.style.display = isActive ? 'inline-block' : 'none';
        localStorage.setItem('sgMirrorMode', isActive);
    }

    function updateOpacity() {
        const opacityValue = opacitySlider.value;
        // ƒê·∫∑t bi·∫øn CSS tr√™n panel, CSS s·∫Ω t·ª± ƒë·ªông √°p d·ª•ng
        smartGridPanel.style.setProperty('--panel-opacity', opacityValue);
        localStorage.setItem('sgOpacity', opacityValue);
    }

    function startDragPanel(e) { if (smartGridPanel.classList.contains('floating') && e.target.classList.contains('drag-handle')) { isDraggingPanel = true; panelOffsetX = e.clientX - smartGridPanel.offsetLeft; panelOffsetY = e.clientY - smartGridPanel.offsetTop; document.addEventListener('mousemove', dragPanel); document.addEventListener('mouseup', stopDragPanel); } }
    function dragPanel(e) { if (isDraggingPanel) { e.preventDefault(); smartGridPanel.style.left = `${e.clientX - panelOffsetX}px`; smartGridPanel.style.top = `${e.clientY - panelOffsetY}px`; } }
    function stopDragPanel() { isDraggingPanel = false; document.removeEventListener('mousemove', dragPanel); document.removeEventListener('mouseup', stopDragPanel); }

    function init() {
        createGridBtn.addEventListener('click', createGrid);
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        micButton.addEventListener('click', toggleVoiceRecognition);
        floatBtn.addEventListener('click', toggleFloatingPanel);
        smartGridPanel.addEventListener('mousedown', startDragPanel);
        prevClusterBtn.addEventListener('click', focusPrevCluster);
        nextClusterBtn.addEventListener('click', focusNextCluster);
        // Y√äU C·∫¶U 2: G·∫Øn listener cho c√°c ƒëi·ªÅu khi·ªÉn ch·∫ø ƒë·ªô g∆∞∆°ng
        mirrorBtn.addEventListener('click', toggleMirrorMode);
        opacitySlider.addEventListener('input', updateOpacity);

        // Kh√¥i ph·ª•c c√†i ƒë·∫∑t ch·∫ø ƒë·ªô g∆∞∆°ng t·ª´ localStorage
        const savedOpacity = localStorage.getItem('sgOpacity') || '0.7';
        opacitySlider.value = savedOpacity;
        smartGridPanel.style.setProperty('--panel-opacity', savedOpacity);
        if (localStorage.getItem('sgMirrorMode') === 'true' && smartGridPanel.classList.contains('floating')) {
             smartGridPanel.classList.add('mirror-mode');
             opacitySlider.style.display = 'inline-block';
             opacityLabel.style.display = 'inline-block';
        }

        setupSpeechRecognition();
        createGrid();
    }
    
    return { init, undo, redo, focusNextCluster, focusPrevCluster, toggleVoiceRecognition };
})();


// --- EVENT LISTENERS CHUNG ---
largePreviewContainer.addEventListener('wheel', (e) => { if (!largePreviewImg.src || largePreviewImg.style.display === 'none') return; e.preventDefault(); const delta = e.deltaY * -0.001; const newScale = Math.min(Math.max(1, imgScale + delta * 5), 10); imgScale = newScale; if (imgScale === 1) imgTranslate = {x: 0, y: 0}; updateTransform(); });
largePreviewContainer.addEventListener('mousedown', (e) => { if (imgScale <= 1 || !largePreviewImg.src || e.button !== 0) return; isPanning = true; startPan = { x: e.clientX - imgTranslate.x, y: e.clientY - imgTranslate.y }; largePreviewContainer.style.cursor = 'grabbing'; });
document.addEventListener('mousemove', (e) => { if (!isPanning) return; e.preventDefault(); imgTranslate.x = e.clientX - startPan.x; imgTranslate.y = e.clientY - startPan.y; updateTransform(); });
document.addEventListener('mouseup', () => { if (isPanning) { isPanning = false; largePreviewContainer.style.cursor = 'grab'; } });
rotateLeftBtn.addEventListener('click', () => transformCurrentImage({ degrees: -90 }));
rotateRightBtn.addEventListener('click', () => transformCurrentImage({ degrees: 90 }));
flipHorizontalBtn.addEventListener('click', () => transformCurrentImage({ flipH: true }));
flipVerticalBtn.addEventListener('click', () => transformCurrentImage({ flipV: true }));

captureBtn.addEventListener('click', async () => {
    if (!largePreviewImg.src || largePreviewImg.style.display === 'none') {
        alert('Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ ch·ª•p.');
        return;
    }
    try {
        const previewContainer = document.getElementById('large-preview-container');
        const originalCanvas = await html2canvas(previewContainer, { useCORS: true, allowTaint: true, scale: 2 });
        const cropCanvas = document.createElement('canvas');
        const cropCtx = cropCanvas.getContext('2d');
        const targetAspectRatio = 4 / 3;
        let sx = 0, sy = 0, sWidth = originalCanvas.width, sHeight = originalCanvas.height;
        const currentAspectRatio = sWidth / sHeight;
        if (currentAspectRatio > targetAspectRatio) { sWidth = sHeight * targetAspectRatio; sx = (originalCanvas.width - sWidth) / 2; } else { sHeight = sWidth / targetAspectRatio; sy = (originalCanvas.height - sHeight) / 2; }
        cropCanvas.width = sWidth; cropCanvas.height = sHeight;
        cropCtx.drawImage(originalCanvas, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
        cropCanvas.toBlob(async (blob) => {
            if (blob) { await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]); alert('ƒê√£ copy ·∫£nh v√†o clipboard!'); } else { throw new Error('Kh√¥ng th·ªÉ t·∫°o blob t·ª´ canvas.'); }
        }, 'image/png');
    } catch (err) { console.error('L·ªói khi copy v√†o clipboard:', err); alert('Kh√¥ng th·ªÉ copy ·∫£nh. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p clipboard v√† ƒë·∫£m b·∫£o trang web ƒëang ch·∫°y tr√™n HTTPS.'); }
});

photoInput.addEventListener('change', (event) => { handleFiles(Array.from(event.target.files)); event.target.value = ''; });
document.addEventListener('paste', async (event) => {
    if (document.activeElement && document.activeElement.closest('#grid-container')) { return; }
    const files = Array.from(event.clipboardData?.items || []).filter(item => item.kind === 'file' && (item.type.startsWith('image/') || item.type === 'application/octet-stream')).map(item => item.getAsFile());
    if (files.length > 0) { event.preventDefault(); await handleFiles(files); }
});

pasteZone.addEventListener('dragover', e => { e.preventDefault(); pasteZone.classList.add('drag-over'); });
pasteZone.addEventListener('dragleave', e => { e.preventDefault(); pasteZone.classList.remove('drag-over'); });
pasteZone.addEventListener('drop', async e => { e.preventDefault(); pasteZone.classList.remove('drag-over'); await handleFiles(Array.from(e.dataTransfer.files)); });
clearBtn.addEventListener('click', () => { if (photoGrid.children.length > 0 && confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a t·∫•t c·∫£ ·∫£nh kh√¥ng?')) { saveState(); photoGrid.innerHTML = ''; photoDataMap.forEach(data => URL.revokeObjectURL(data.blob)); photoDataMap.clear(); photoIdCounter = 0; lastSelectedWrapper = null; updateCurrentState(); updatePreview(null); syncNameListFromInputs(); } });
assignNamesBtn.addEventListener('click', () => { saveState(); const nameList = nameListTextArea.value.trim().split('\n').filter(Boolean); if (nameList.length === 0) return; const wrappers = Array.from(photoGrid.querySelectorAll('.photo-wrapper')); if (rangeNameToggle.checked) { const start = parseInt(document.getElementById('name-range-start').value, 10); const end = parseInt(document.getElementById('name-range-end').value, 10); if (applySingleNameToggle.checked) { const singleName = nameList[0].trim(); for (let i = start - 1; i < Math.min(end, wrappers.length); i++) { const wrapper = wrappers[i]; if (wrapper) { wrapper.querySelector('.name-container input[type="text"]').value = `${i + 1}. ${singleName}`; } } } else { let nameIndex = 0; for (let i = start - 1; i < Math.min(end, wrappers.length); i++) { if (nameIndex >= nameList.length) break; const wrapper = wrappers[i]; if(wrapper) { wrapper.querySelector('.name-container input[type="text"]').value = `${i + 1}. ${nameList[nameIndex].trim()}`; } nameIndex++; } } } else { wrappers.forEach((wrapper, index) => { if (nameList[index]) wrapper.querySelector('.name-container input[type="text"]').value = `${index + 1}. ${nameList[index].trim()}`; }); } updateCurrentState(); syncNameListFromInputs(); });
rangeNameToggle.addEventListener('change', (e) => { rangeInputsContainer.style.display = e.target.checked ? 'flex' : 'none'; });
downloadAllBtn.addEventListener('click', () => generateZip(Array.from(photoGrid.querySelectorAll('.photo-wrapper')), 'all_photos.zip'));
undoBtn.addEventListener('click', restoreStateFromHistory);
lockToggle.addEventListener('change', (e) => { initializeSortable(!e.target.checked); });
gridToggleBtn.addEventListener('click', () => { photoGrid.classList.toggle('dense-mode'); gridToggleBtn.textContent = photoGrid.classList.contains('dense-mode') ? 'L∆∞·ªõi th∆∞·ªùng' : 'L∆∞·ªõi x2'; });
deleteSelectedBtn.addEventListener('click', () => { const selectedWrappers = photoGrid.querySelectorAll('.photo-wrapper.selected-photo'); if (selectedWrappers.length === 0) { alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt ·∫£nh ƒë·ªÉ x√≥a.'); return; } const isNumericMode = pageBody.classList.contains('numeric-mode'); const confirmMessage = isNumericMode ? `B·∫°n c√≥ ch·∫Øc mu·ªën ·∫©n ${selectedWrappers.length} ·∫£nh ƒë√£ ch·ªçn kh·ªèi Ch·∫ø ƒë·ªô S·ªë li·ªáu kh√¥ng?` : `B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a vƒ©nh vi·ªÖn ${selectedWrappers.length} ·∫£nh ƒë√£ ch·ªçn kh√¥ng?`; if (confirm(confirmMessage)) { saveState(); if (isNumericMode) { selectedWrappers.forEach(wrapper => { wrapper.dataset.numericIgnored = 'true'; wrapper.querySelector('.exclude-numeric-btn').innerHTML = '&#9733;'; wrapper.classList.remove('selected-photo'); }); applyNumericFilter(); } else { selectedWrappers.forEach(wrapper => { const id = wrapper.getAttribute('data-photo-id'); if (id && photoDataMap.has(id)) { photoDataMap.delete(id); } wrapper.remove(); }); updateNumberingAndSync(); } lastSelectedWrapper = null; updateCurrentState(); updatePreview(null); } });
hideAllImagesBtn.addEventListener('click', () => { pageWrapper.classList.toggle('grid-hidden'); });
nextImageBtn.addEventListener('click', () => navigateImage('next'));
prevImageBtn.addEventListener('click', () => navigateImage('prev'));
voiceInputBtn.addEventListener('click', startVoiceRecognition);
toggleSmartGridBtn.addEventListener('click', () => {
    const isVisible = smartGridPanel.style.display === 'block';
    smartGridPanel.style.display = isVisible ? 'none' : 'block';
    toggleSmartGridBtn.style.backgroundColor = isVisible ? '#17a2b8' : '#28a745';
});

document.addEventListener('keydown', (e) => {
    if (e.target.closest('#hotkey-settings')) return;
    const isSmartGridActive = document.activeElement && document.activeElement.closest('#smart-grid-panel');
    if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); if (isSmartGridActive) { smartGrid.undo(); } else { restoreStateFromHistory(); } return; }
    if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); if (isSmartGridActive) { smartGrid.redo(); } return; }
    if (isSmartGridActive && (e.key === 'Tab')) {
        e.preventDefault();
        if (e.shiftKey) { smartGrid.focusPrevCluster(); } else { smartGrid.focusNextCluster(); }
        return;
    }
    if (e.key === 'Delete' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName) && !isSmartGridActive) { e.preventDefault(); deleteSelectedBtn.click(); }
    const hotkeyCombination = e.shiftKey ? `Shift+${e.key}` : e.code;
    const action = Object.keys(hotkeys).find(key => hotkeys[key] === hotkeyCombination || hotkeys[key] === e.key || hotkeys[key] === e.code);
    if (action) {
        let actionHandled = true;
        switch (action) {
            case 'nextImage': navigateImage('next'); break;
            case 'prevImage': navigateImage('prev'); break;
            case 'editName': if (lastSelectedWrapper && previewNameInput.style.display !== 'none') { previewNameInput.focus(); handleNameInputFocus(previewNameInput); } break;
            case 'rotateLeft': rotateLeftBtn.click(); break;
            case 'rotateRight': rotateRightBtn.click(); break;
            case 'pinToolbar': pinToolbarBtn.click(); break;
            case 'translateName': translateFocusedInput(); break;
            case 'voiceInput': if (!isSmartGridActive) startVoiceRecognition(); break;
            case 'smartGridVoice': if (isSmartGridActive) smartGrid.toggleVoiceRecognition(); break;
            case 'smartGridPrev': if (isSmartGridActive) smartGrid.focusPrevCluster(); break;
            case 'smartGridNext': if (isSmartGridActive) smartGrid.focusNextCluster(); break;
            default: actionHandled = false;
        }
        if(actionHandled) { e.preventDefault(); }
    }
});

previewNameInput.addEventListener('input', () => { if (lastSelectedWrapper) { const gridInput = lastSelectedWrapper.querySelector('.name-container input[type="text"]'); if (gridInput) { gridInput.value = previewNameInput.value; syncNameListFromInputs(); clearTimeout(previewNameInput.saveTimeout); previewNameInput.saveTimeout = setTimeout(() => { saveState(); updateCurrentState(); }, 500); } } });
function handleNameInputFocus(target) { if (!smartSelectToggle.checked) { const fullValue = target.value; const prefixMatch = fullValue.match(/^\d+\.\s+/); const startIndex = prefixMatch ? prefixMatch[0].length : 0; setTimeout(() => target.setSelectionRange(startIndex, fullValue.length), 0); return; } const fullValue = target.value; const prefixMatch = fullValue.match(/^\d+\.\s*/); const prefixLength = prefixMatch ? prefixMatch[0].length : 0; const namePart = fullValue.substring(prefixLength); const numericMatch = namePart.match(/-?\d+(\.\d+)?/); if (numericMatch) { const numericValue = numericMatch[0]; const startIndexInNamePart = numericMatch.index; const absoluteStartIndex = prefixLength + startIndexInNamePart; const absoluteEndIndex = absoluteStartIndex + numericValue.length; setTimeout(() => target.setSelectionRange(absoluteStartIndex, absoluteEndIndex), 0); } else { setTimeout(() => target.setSelectionRange(prefixLength, fullValue.length), 0); } }
document.addEventListener('focusin', (event) => { const target = event.target; if (target.matches('input[type="text"], textarea')) { lastFocusedInputForVoice = target; if (target.matches('.name-container input[type="text"], #preview-name-input')) { handleNameInputFocus(target); } } });
highlightTallBtn.addEventListener('click', () => { pageWrapper.classList.toggle('highlight-tall-active'); if (pageWrapper.classList.contains('highlight-tall-active')) { highlightTallBtn.style.backgroundColor = '#28a745'; photoGrid.querySelectorAll('.photo-wrapper').forEach(wrapper => { const id = wrapper.getAttribute('data-photo-id'); const data = photoDataMap.get(id); if(data){ const img = new Image(); img.onload = () => { if (img.naturalHeight > img.naturalWidth) { wrapper.classList.add('is-tall'); } URL.revokeObjectURL(img.src); }; img.src = URL.createObjectURL(data.blob); } }); } else { highlightTallBtn.style.backgroundColor = ''; photoGrid.querySelectorAll('.is-tall').forEach(el => el.classList.remove('is-tall')); } });
togglePreviewBtn.addEventListener('click', () => { pageWrapper.classList.toggle('preview-hidden'); togglePreviewBtn.textContent = pageWrapper.classList.contains('preview-hidden') ? 'Hi·ªán Preview' : '·∫®n Preview'; });
function updateNumericFilteredNamesList() { const filteredElements = Array.from(photoGrid.querySelectorAll('.photo-wrapper:not(.hidden-by-filter)')); const names = filteredElements.map(el => el.querySelector('.name-container input').value); numericFilteredNamesList.value = names.join('\n'); }
function applyNumericFilter() { const wrappers = photoGrid.querySelectorAll('.photo-wrapper'); const nameRegex = /\d/; wrappers.forEach(wrapper => { const nameInput = wrapper.querySelector('.name-container input[type="text"]'); const hasNumber = nameRegex.test(removeLeadingOrderPrefix(nameInput.value)); const isIgnored = wrapper.dataset.numericIgnored === 'true'; if (hasNumber && !isIgnored) { wrapper.classList.remove('hidden-by-filter'); } else { wrapper.classList.add('hidden-by-filter'); } }); updateNumericFilteredNamesList(); }
numericFilterBtn.addEventListener('click', () => { pageBody.classList.toggle('numeric-mode'); if (pageBody.classList.contains('numeric-mode')) { numericFilterBtn.style.backgroundColor = '#28a745'; numericModeControls.style.display = 'flex'; applyNumericFilter(); } else { numericFilterBtn.style.backgroundColor = '#17a2b8'; numericModeControls.style.display = 'none'; photoGrid.querySelectorAll('.hidden-by-filter').forEach(el => el.classList.remove('hidden-by-filter')); } updatePreview(lastSelectedWrapper); });
downloadNumericBtn.addEventListener('click', () => { const filteredElements = Array.from(photoGrid.querySelectorAll('.photo-wrapper:not(.hidden-by-filter)')); generateZip(filteredElements, 'numeric_photos.zip'); });
applyNumericSuggestionsBtn.addEventListener('click', () => { saveState(); const visibleWrappers = Array.from(photoGrid.querySelectorAll('.photo-wrapper:not(.hidden-by-filter)')); const suggestionsList = numericNameSuggestions.value.trim().split('\n').filter(Boolean); const suggestionCount = parseInt(suggestionCountSelect.value, 10); const numItems = visibleWrappers.length; if (suggestionsList.length < numItems * suggestionCount) { return alert(`Danh s√°ch t√™n g·ª£i √Ω kh√¥ng ƒë·ªß. C·∫ßn ${numItems * suggestionCount} d√≤ng cho ${numItems} ·∫£nh v·ªõi ${suggestionCount} g·ª£i √Ω m·ªói ·∫£nh.`); } let namesChanged = false; visibleWrappers.forEach((wrapper, index) => { const itemSuggestions = []; for (let i = 0; i < suggestionCount; i++) { const suggestionIndex = index + (numItems * i); if(suggestionsList[suggestionIndex]){ itemSuggestions.push(suggestionsList[suggestionIndex].trim()); } } wrapper.dataset.suggestions = JSON.stringify(itemSuggestions); if (suggestionCount === 1 && itemSuggestions.length > 0) { const nameInput = wrapper.querySelector('.name-container input[type="text"]'); const currentPrefix = nameInput.value.match(/^\d+\.\s+/); const newName = (currentPrefix ? currentPrefix[0] : '') + itemSuggestions[0]; if (nameInput.value !== newName) { nameInput.value = newName; namesChanged = true; } } }); if (namesChanged) { syncNameListFromInputs(); if (lastSelectedWrapper) { previewNameInput.value = lastSelectedWrapper.querySelector('.name-container input[type="text"]').value; } } alert(`ƒê√£ g√°n g·ª£i √Ω cho ${numItems} ·∫£nh.` + (suggestionCount === 1 ? ' C√°c t√™n ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông √°p d·ª•ng.' : '')); if(lastSelectedWrapper) updateSuggestionButtons(lastSelectedWrapper); updateCurrentState(); });
async function replaceImageForWrapper(wrapper, newFile) { if (!wrapper || !newFile || (!newFile.type.startsWith('image/') && newFile.type !== 'application/octet-stream')) return; saveState(); const id = wrapper.getAttribute('data-photo-id'); if (!id) return; let processedBlob = await processImageRotation(newFile); if (processedBlob.type === 'application/octet-stream') { const originalName = newFile.name; const correctedType = getMimeTypeFromName(originalName, processedBlob.type); if (correctedType !== processedBlob.type) { processedBlob = new Blob([processedBlob], { type: correctedType }); } } photoDataMap.set(id, { ...photoDataMap.get(id), blob: processedBlob }); const newUrl = URL.createObjectURL(processedBlob); wrapper.querySelector('.photo-item').src = newUrl; wrapper.classList.toggle('is-small', newFile.size < 40000); if (pageWrapper.classList.contains('highlight-tall-active')) { const img = new Image(); img.onload = () => { wrapper.classList.toggle('is-tall', img.naturalHeight > img.naturalWidth); URL.revokeObjectURL(img.src); }; img.src = newUrl; } if (wrapper.classList.contains('selected-photo')) { updatePreview(wrapper); } updateCurrentState(); }
mainContentEl.addEventListener('click', async (event) => { const target = event.target; const wrapper = target.closest('.photo-wrapper'); document.querySelectorAll('.replace-panel').forEach(panel => { if (!panel.contains(target) && !panel.previousElementSibling.contains(target)) { panel.style.display = 'none'; } }); if (wrapper) { if (target.classList.contains('delete-btn')) { saveState(); const wasSelected = wrapper.classList.contains('selected-photo'); if (lastSelectedWrapper === wrapper) lastSelectedWrapper = null; wrapper.remove(); updateNumberingAndSync(); updateCurrentState(); if (wasSelected) updatePreview(null); return; } if (target.classList.contains('exclude-numeric-btn')) { wrapper.dataset.numericIgnored = wrapper.dataset.numericIgnored === 'true' ? 'false' : 'true'; target.innerHTML = wrapper.dataset.numericIgnored === 'true' ? '&#9733;' : '&#10007;'; if (pageBody.classList.contains('numeric-mode')) { applyNumericFilter(); } saveState(); return; } if (target.classList.contains('replace-btn')) { const panel = wrapper.querySelector('.replace-panel'); panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex'; return; } if (target.classList.contains('replace-from-file-btn')) { const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = 'image/*,application/octet-stream'; fileInput.onchange = (e) => { if (e.target.files.length > 0) { replaceImageForWrapper(wrapper, e.target.files[0]); } }; fileInput.click(); wrapper.querySelector('.replace-panel').style.display = 'none'; return; } if (target.classList.contains('replace-from-clipboard-btn')) { try { const clipboardItems = await navigator.clipboard.read(); const imageItem = clipboardItems.find(item => item.types.some(type => type.startsWith('image/') || type === 'application/octet-stream')); if (imageItem) { const imageType = imageItem.types.find(type => type.startsWith('image/') || type === 'application/octet-stream'); const blob = await imageItem.getType(imageType); const file = new File([blob], "clipboard_image.png", { type: blob.type }); await replaceImageForWrapper(wrapper, file); } else { alert('Kh√¥ng t√¨m th·∫•y ·∫£nh n√†o trong clipboard.'); } } catch (err) { console.error('L·ªói khi ƒë·ªçc clipboard:', err); alert('Kh√¥ng th·ªÉ truy c·∫≠p clipboard. Vui l√≤ng ƒë·∫£m b·∫£o b·∫°n ƒë√£ c·∫•p quy·ªÅn v√† ƒëang s·ª≠ d·ª•ng k·∫øt n·ªëi an to√†n (HTTPS).'); } wrapper.querySelector('.replace-panel').style.display = 'none'; return; } if (target.closest('.img-container')) { if (!event.ctrlKey && !event.shiftKey) { document.querySelectorAll('.selected-photo').forEach(w => w.classList.remove('selected-photo')); wrapper.classList.add('selected-photo'); } else if (event.ctrlKey) { wrapper.classList.toggle('selected-photo'); } else if (event.shiftKey && lastSelectedWrapper) { const wrappers = Array.from(photoGrid.querySelectorAll('.photo-wrapper:not(.hidden-by-filter)')); const [start, end] = [wrappers.indexOf(lastSelectedWrapper), wrappers.indexOf(wrapper)].sort((a,b)=>a-b); for (let i = start; i <= end; i++) wrappers[i].classList.add('selected-photo'); } lastSelectedWrapper = wrapper.classList.contains('selected-photo') ? wrapper : (photoGrid.querySelector('.selected-photo') || null); updatePreview(lastSelectedWrapper); } } });
mainContentEl.addEventListener('input', (event) => { const target = event.target; if (target.matches('.name-container input[type="text"]')) { const wrappers = Array.from(photoGrid.querySelectorAll('.photo-wrapper')); const index = wrappers.indexOf(target.closest('.photo-wrapper')); const allInputs = photoGrid.querySelectorAll('.name-container input[type="text"]'); const names = Array.from(allInputs).map(inp => removeLeadingOrderPrefix(inp.value.trim())); nameListTextArea.value = names.join('\n'); if (index >= 0) { const lineHeight = 18; const scrollPos = index * lineHeight; nameListTextArea.scrollTop = scrollPos; } if (target.closest('.photo-wrapper').classList.contains('selected-photo')) { previewNameInput.value = target.value; } } if (target.matches('.name-container input[type="text"], #name-list, #local-note-area')) { clearTimeout(target.saveTimeout); target.saveTimeout = setTimeout(() => { saveState(); updateCurrentState(); }, 500); } });
localNoteArea.addEventListener('input', () => { localStorage.setItem('localNote', localNoteArea.value); });
textReplacementRulesEl.addEventListener('input', () => { localStorage.setItem('textReplacementRules', textReplacementRulesEl.value); });
hotkeySettingsContainer.addEventListener('keydown', (e) => { const input = e.target; if (input.tagName === 'INPUT') { e.preventDefault(); const keyValue = e.shiftKey ? `Shift+${e.key}` : (e.code.startsWith('Key') || e.code.startsWith('Digit') || e.code.startsWith('Arrow') ? e.code : e.key); input.value = keyValue; const action = input.dataset.action; if (action) { hotkeys[action] = keyValue; saveHotkeys(); } } });
pinToolbarBtn.addEventListener('click', () => { const isCurrentlyPinned = pageWrapper.classList.contains('toolbar-pinned'); setToolbarPinned(!isCurrentlyPinned); });
document.addEventListener('mousemove', (e) => { if (!pageWrapper.classList.contains('toolbar-pinned')) { const toolbarWidth = 450; const hideThreshold = toolbarWidth + 200; if (e.clientX < 15) { toolbar.classList.add('visible'); } else if (e.clientX > hideThreshold) { toolbar.classList.remove('visible'); } } });

function initializeApp() {
    loadHotkeys();
    initializeSpeechRecognition();
    smartGrid.init(); // Kh·ªüi t·∫°o module B·∫£ng t√≠nh
    const savedNote = localStorage.getItem('localNote');
    if (savedNote) { localNoteArea.value = savedNote; }
    const savedRules = localStorage.getItem('textReplacementRules');
    if (savedRules) { textReplacementRulesEl.value = savedRules; }
    const isPinned = localStorage.getItem('toolbarPinned') === 'true';
    setToolbarPinned(isPinned);
    reInitializeApp();
    saveState();
}

initializeApp();
</script>
</body>
</html>
