<!DOCTYPE html>
<html>
<head>
<title>S·∫Øp x·∫øp ·∫£nh - Giao di·ªán m·ªõi (ƒê√£ n√¢ng c·∫•p Pro)</title>
<meta charset="UTF-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<style>
    /* === CSS CHUNG === */
    body { font-family: sans-serif; margin: 0; background-color: #f4f4f4; color: #333; }
    button, label.custom-file-label { padding: 8px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s; white-space: nowrap; text-align: center; }
    button:hover, label.custom-file-label:hover { opacity: 0.85; }
    input[type="file"].custom-file-input { display: none; }
    h3 { margin: 0 0 10px 0; font-size: 1.1em; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; }

    /* === B·ªê C·ª§C T·ªîNG TH·ªÇ === */
    .page-wrapper { display: flex; height: 100vh; gap: 15px; }
    .main-column { flex: 1; display: flex; flex-direction: column; min-width: 500px; overflow-y: hidden; }
    .main-content { padding: 15px; overflow-y: auto; flex-grow: 1; }
    
    .preview-column {
        width: 50%; max-width: 50%; flex-shrink: 0; background-color: #e9ecef;
        padding: 15px; display: flex; flex-direction: column; position: sticky;
        top: 0; height: 100vh; box-sizing: border-box;
    }

    /* === THANH C√îNG C·ª§ === */
    .controls { position: sticky; top: 0; z-index: 1000; background-color: #fff; padding: 10px; border-bottom: 1px solid #ddd; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; }
    .control-wrapper { display: flex; gap: 15px; width: 100%; }
    .control-area { flex: 1; display: flex; }
    .control-group { display: flex; flex-direction: column; gap: 8px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 5px; background-color: #fcfcfc; width: 100%; }
    .action-buttons, .name-options { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .action-buttons > * { flex-grow: 1; }
    .action-buttons label { display: flex; align-items: center; justify-content: center; gap: 5px; }

    #paste-zone { padding: 8px; border: 2px dashed #ccc; border-radius: 4px; text-align: center; color: #666; background-color: #fafafa; transition: background-color 0.2s, border-color 0.2s; }
    #paste-zone.drag-over { background-color: #e0e0e0; border-color: #007bff; }
    
    /* Highlight d√≤ng ƒëang edit trong textarea */
    #name-list { 
        resize: vertical; min-height: 50px; height: 100px; padding: 5px; 
        border: 1px solid #ccc; border-radius: 4px; width: 100%; 
        font-family: monospace; line-height: 1.5; white-space: pre;
    }
    
    #range-inputs-container { display: flex; gap: 5px; align-items: center; }
    #range-inputs-container input[type="number"] { width: 50px; padding: 3px; }
    #download-progress { display: none; width: 100%; margin-top: 10px; }

    /* === XEM TR∆Ø·ªöC ·∫¢NH === */
    #large-preview-container {
        flex-grow: 1; display: flex; align-items: center; justify-content: center;
        background-color: #333; border-radius: 8px;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        overflow: hidden; min-height: 0; position: relative;
        cursor: grab; user-select: none;
    }
    #large-preview-container:active { cursor: grabbing; }

    #large-preview-img { 
        max-width: 100%; max-height: 100%; object-fit: contain; 
        transform-origin: center center;
        will-change: transform;
        /* Quan tr·ªçng ƒë·ªÉ kh√¥ng b·ªã k√©o ·∫£nh ƒëi b·ªüi tr√¨nh duy·ªát */
        pointer-events: none; 
        user-select: none;
        -webkit-user-drag: none;
    }
    .preview-placeholder { color: #ccc; font-size: 1.2em; pointer-events: none; }
    
    .preview-controls { display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center; flex-wrap: wrap; gap: 5px; }
    .rotate-controls { display: flex; gap: 5px; }

    /* === PHOTO GRID === */
    .photo-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; }
    .photo-grid.dense-mode { grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); gap: 8px; }
    .photo-grid.dense-mode .name-container input[type="text"] { font-size: 9px; padding: 1px 2px; height: 20px; }

    .photo-wrapper { position: relative; display: flex; flex-direction: column; align-items: center; }
    .img-container { position: relative; width: 100%; padding-top: 75%; overflow: hidden; border-radius: 4px; background-color: #eee; cursor: pointer; transition: outline 0.2s ease-in-out; }
    .photo-item { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border: none; pointer-events: none; }
    .delete-btn { position: absolute; z-index: 10; top: 4px; right: 4px; width: 22px; height: 22px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 14px; line-height: 22px; text-align: center; padding: 0; opacity: 0; transition: opacity 0.2s; }
    .photo-wrapper:hover .delete-btn { opacity: 1; }
    .name-container { display: flex; align-items: center; width: 100%; margin-top: 5px; }
    
    .name-container input[type="text"] { flex: 1; padding: 3px 4px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 3px; min-width: 0; font-size: 10.5px; height: 24px; }

    /* === SORTABLE & EFFECTS === */
    .ghost-class { opacity: 0.4; background-color: #c0e0ff; border: 2px dashed #007bff; }
    .drag-class { opacity: 0.8; transform: scale(1.05); } 
    .selected-photo .img-container { outline: 3px solid #007bff; outline-offset: 2px; }
    @keyframes yellow-flash { from { outline: 4px solid gold; } to { outline: 4px solid transparent; } }
    .newly-added .img-container { animation: yellow-flash 1.5s ease-out; }

</style>
</head>
<body>

<div class="page-wrapper">
    <div class="main-column">
        <div class="controls">
            <div class="control-wrapper">
                <div class="control-area">
                    <div class="control-group">
                        <div class="action-buttons">
                            <label for="photo-input" class="custom-file-label">T·∫£i ·∫£nh l√™n</label>
                            <div id="paste-zone">Ho·∫∑c k√©o th·∫£ / d√°n ·∫£nh</div>
                            <button id="clear-btn" style="background-color: #dc3545;">X√≥a t·∫•t c·∫£</button>
                            <button id="download-all-btn">T·∫£i t·∫•t c·∫£</button>
                            <button id="undo-btn">Ho√†n t√°c (Ctrl+Z)</button>
                            <button id="grid-toggle-btn" style="background-color: #6c757d;">Ch·∫ø ƒë·ªô l∆∞·ªõi x2</button>
                            <label><input type="checkbox" id="lock-toggle"> Kh√≥a k√©o th·∫£</label>
                            <label><input type="checkbox" id="smart-select-toggle"> B·∫≠t ch·ªçn s·ªë li·ªáu</label>
                        </div>
                    </div>
                </div>
                <div class="control-area">
                    <div class="control-group">
                        <div class="name-options">
                            <textarea id="name-list" placeholder="Danh s√°ch t√™n (t·ª± ƒë·ªông cu·ªôn khi s·ª≠a t√™n ·∫£nh)"></textarea>
                            <div style="display:flex; flex-direction:column; gap: 8px; align-self: flex-end; width: 100%;">
                                <div id="range-name-options">
                                    <label><input type="checkbox" id="range-name-toggle"> Ch√®n t√™n theo kho·∫£ng</label>
                                    <div id="range-inputs-container" style="display: none;">
                                        <label for="name-range-start">T·ª´:</label>
                                        <input type="number" id="name-range-start" value="1" min="1">
                                        <label for="name-range-end">ƒê·∫øn:</label>
                                        <input type="number" id="name-range-end" value="10" min="1">
                                    </div>
                                </div>
                                <button id="assign-names-btn">Ch√®n t√™n t·ª´ danh s√°ch</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <progress id="download-progress" value="0" max="100"></progress>
        </div>

        <div class="main-content" id="main-content">
            <div id="photo-grid-main" class="photo-grid"></div>
        </div>
    </div>

    <div class="preview-column">
        <div class="preview-controls">
            <h3>Xem tr∆∞·ªõc ·∫£nh</h3>
            <div class="rotate-controls">
                <button id="rotate-left-btn" title="Xoay tr√°i 90 ƒë·ªô">‚Ü∫ Tr√°i</button>
                <button id="rotate-right-btn" title="Xoay ph·∫£i 90 ƒë·ªô">‚Üª Ph·∫£i</button>
            </div>
            <button id="capture-btn" title="Copy v√πng hi·ªÉn th·ªã v√†o Clipboard (T·ª∑ l·ªá 3:4)">üìã Copy ·∫£nh (3:4)</button>
        </div>
        <div id="large-preview-container">
            <span id="preview-placeholder" class="preview-placeholder">Ch·ªçn ·∫£nh ƒë·ªÉ xem. LƒÉn chu·ªôt ƒë·ªÉ Zoom, Gi·ªØ chu·ªôt tr√°i ƒë·ªÉ K√©o.</span>
            <img id="large-preview-img" src="" alt="" draggable="false">
        </div>
    </div>
</div>

<input type="file" id="photo-input" multiple accept="image/*" class="custom-file-input">

<script>
// --- C√°c bi·∫øn to√†n c·ª•c ---
const photoInput = document.getElementById('photo-input');
const clearBtn = document.getElementById('clear-btn');
const assignNamesBtn = document.getElementById('assign-names-btn');
const downloadAllBtn = document.getElementById('download-all-btn');
const undoBtn = document.getElementById('undo-btn');
const lockToggle = document.getElementById('lock-toggle');
const pasteZone = document.getElementById('paste-zone');
const mainContentEl = document.getElementById('main-content');
const nameListTextArea = document.getElementById('name-list');
const rangeNameToggle = document.getElementById('range-name-toggle');
const rangeInputsContainer = document.getElementById('range-inputs-container');
const largePreviewImg = document.getElementById('large-preview-img');
const largePreviewContainer = document.getElementById('large-preview-container');
const previewPlaceholder = document.getElementById('preview-placeholder');
const smartSelectToggle = document.getElementById('smart-select-toggle');
const gridToggleBtn = document.getElementById('grid-toggle-btn');
const captureBtn = document.getElementById('capture-btn');
const rotateLeftBtn = document.getElementById('rotate-left-btn');
const rotateRightBtn = document.getElementById('rotate-right-btn');


let photoGrid = document.getElementById('photo-grid-main');
let sortableInstance = null;
let photoIdCounter = 0;
const photoDataMap = new Map(); // Store blob data and rotation
let history = [];
let currentState = null;
let lastSelectedWrapper = null;
let lastFocusedInput = null;
let isDownloading = false;
let draggedItems = [];

// Bi·∫øn cho Zoom & Pan
let imgScale = 1;
let imgTranslate = { x: 0, y: 0 };
let isPanning = false;
let startPan = { x: 0, y: 0 };

// --- C√°c h√†m ti·ªán √≠ch ---
function removeLeadingOrderPrefix(filename) { return filename.replace(/^\d+\.\s+/, ''); }
function syncInputAttributes() { mainContentEl.querySelectorAll('input[type="text"]').forEach(input => input.setAttribute('value', input.value)); mainContentEl.querySelectorAll('textarea').forEach(textarea => textarea.textContent = textarea.value); mainContentEl.querySelectorAll('input[type="checkbox"]').forEach(input => { if (input.checked) input.setAttribute('checked', 'checked'); else input.removeAttribute('checked'); }); }
function saveState() { 
    syncInputAttributes(); 
    const stateHTML = mainContentEl.innerHTML; 
    if (stateHTML !== currentState) { 
        if (currentState !== null) history.push(currentState); 
        if (history.length > 50) history.shift(); 
        currentState = stateHTML; 
    } 
}
function updateCurrentState() { syncInputAttributes(); currentState = mainContentEl.innerHTML; }
function restoreStateFromHistory() { 
    if (history.length > 0) { 
        const stateToRestore = history.pop(); 
        mainContentEl.innerHTML = stateToRestore; 
        currentState = stateToRestore; 
        reInitializeApp(); 
    } else { 
        alert('Kh√¥ng c√≥ h√†nh ƒë·ªông n√†o ƒë·ªÉ ho√†n t√°c.'); 
    } 
}

// X·ª≠ l√Ω xoay ·∫£nh t·ª´ File g·ªëc khi upload (n·∫øu c√≥ EXIF)
function processImageRotation(file) {
    return new Promise((resolve, reject) => {
        // Tr·∫£ v·ªÅ file g·ªëc, vi·ªác xoay s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω th·ªß c√¥ng ho·∫∑c khi render
        // ·ªû ƒë√¢y gi·ªØ nguy√™n file g·ªëc ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng
        resolve(file); 
    });
}

// === T√çNH NƒÇNG XOAY ·∫¢NH V√Ä L∆ØU BLOB M·ªöI ===
async function rotateCurrentPhoto(degrees) {
    if (!lastSelectedWrapper) return;
    const id = lastSelectedWrapper.getAttribute('data-photo-id');
    if (!id || !photoDataMap.has(id)) return;

    saveState();

    const currentData = photoDataMap.get(id);
    const blob = currentData.blob;
    
    // T·∫°o Canvas ƒë·ªÉ xoay
    const bitmap = await createImageBitmap(blob);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // ƒê·∫£o chi·ªÅu width/height n·∫øu xoay 90 ho·∫∑c 270 (-90)
    if (Math.abs(degrees) === 90) {
        canvas.width = bitmap.height;
        canvas.height = bitmap.width;
    } else {
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
    }

    // D·ªãch chuy·ªÉn t√¢m v√† xoay
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate(degrees * Math.PI / 180);
    ctx.drawImage(bitmap, -bitmap.width / 2, -bitmap.height / 2);

    // Xu·∫•t ra Blob m·ªõi
    canvas.toBlob((newBlob) => {
        if (!newBlob) return;
        
        // C·∫≠p nh·∫≠t Map
        photoDataMap.set(id, { ...currentData, blob: newBlob });
        
        // T·∫°o URL m·ªõi
        const newUrl = URL.createObjectURL(newBlob);
        
        // C·∫≠p nh·∫≠t Thumbnail trong Grid
        const thumbImg = lastSelectedWrapper.querySelector('.photo-item');
        thumbImg.src = newUrl;
        
        // C·∫≠p nh·∫≠t Preview l·ªõn
        largePreviewImg.src = newUrl;
        largePreviewImg.setAttribute('data-current-src', newUrl);
        
        // Reset Zoom ƒë·ªÉ tr√°nh l·ªói hi·ªÉn th·ªã sau khi xoay
        resetZoom();

        updateCurrentState();

    }, blob.type || 'image/jpeg', 0.95);
}

// === ZOOM & PAN LOGIC (ƒê∆∞·ª£c l√†m m∆∞·ª£t) ===
function resetZoom() {
    imgScale = 1;
    imgTranslate = { x: 0, y: 0 };
    updateTransform();
}

function updateTransform() {
    // Kh√¥ng d√πng transition trong JS ƒë·ªÉ tr√°nh lag khi k√©o, d√πng CSS will-change
    largePreviewImg.style.transform = `translate(${imgTranslate.x}px, ${imgTranslate.y}px) scale(${imgScale})`;
}

function updatePreview(wrapper) {
    const selectedWrappers = photoGrid.querySelectorAll('.photo-wrapper.selected-photo');
    if (selectedWrappers.length === 1) {
        const singleWrapper = selectedWrappers[0];
        const id = singleWrapper.getAttribute('data-photo-id');
        const data = photoDataMap.get(id);
        
        // S·ª≠ d·ª•ng Blob URL t·ª´ Map ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng v√† tr·∫°ng th√°i xoay
        const imgSrc = data ? URL.createObjectURL(data.blob) : singleWrapper.querySelector('.photo-item').src;
        
        if (largePreviewImg.getAttribute('data-current-src') !== imgSrc) {
            largePreviewImg.src = imgSrc;
            largePreviewImg.alt = singleWrapper.querySelector('input[type="text"]').value;
            largePreviewImg.setAttribute('data-current-src', imgSrc);
            resetZoom();
        }
        previewPlaceholder.style.display = 'none';
        largePreviewImg.style.display = 'block';
    } else {
        largePreviewImg.src = "";
        largePreviewImg.alt = "";
        largePreviewImg.removeAttribute('data-current-src');
        largePreviewImg.style.display = 'none';
        previewPlaceholder.style.display = 'block';
    }
}

function createPhotoElement(id, processedBlob, originalName) {
    const wrapper = document.createElement('div');
    wrapper.className = 'photo-wrapper newly-added';
    wrapper.setAttribute('data-photo-id', id);

    const imgContainer = document.createElement('div');
    imgContainer.className = 'img-container';

    const img = document.createElement('img');
    img.className = 'photo-item';
    img.src = URL.createObjectURL(processedBlob);
    // Prevent dragging image element natively
    img.draggable = false; 

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.innerHTML = '&times;';
    deleteBtn.title = 'X√≥a ·∫£nh n√†y';

    const nameContainer = document.createElement('div');
    nameContainer.className = 'name-container';
    
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    const nameWithoutExtension = originalName.replace(/\.[^/.]+$/, "");
    const cleanName = removeLeadingOrderPrefix(nameWithoutExtension);
    nameInput.value = cleanName;

    imgContainer.appendChild(img);
    imgContainer.appendChild(deleteBtn);

    nameContainer.appendChild(nameInput);

    wrapper.appendChild(imgContainer);
    wrapper.appendChild(nameContainer);

    photoDataMap.set(id, { blob: processedBlob, originalName: originalName });
    setTimeout(() => wrapper.classList.remove('newly-added'), 1500);
    return wrapper;
}

function syncNameListFromInputs() {
    const allNameInputs = photoGrid.querySelectorAll('.name-container input[type="text"]');
    const namesArray = Array.from(allNameInputs).map(input => {
        return removeLeadingOrderPrefix(input.value.trim());
    });
    nameListTextArea.value = namesArray.join('\n');
}

function updateNumberingAndSync() {
    const wrappers = photoGrid.querySelectorAll('.photo-wrapper');
    wrappers.forEach((wrapper, index) => {
        const nameInput = wrapper.querySelector('.name-container input[type="text"]');
        if (nameInput) {
            const currentName = removeLeadingOrderPrefix(nameInput.value);
            nameInput.value = `${index + 1}. ${currentName}`;
        }
    });
    syncNameListFromInputs();
}

async function processAndDisplayFiles(filesArray) {
    if (filesArray.length === 0) return;
    saveState();
    const selectedWrappers = photoGrid.querySelectorAll('.photo-wrapper.selected-photo');
    const insertionPoint = selectedWrappers.length === 1 ? selectedWrappers[0] : null;
    const fragment = document.createDocumentFragment();
    let lastAddedElement = null;

    for (const file of filesArray) {
        if (!file.type.startsWith('image/')) continue;
        try {
            const processedBlob = await processImageRotation(file);
            const id = `photo-${photoIdCounter++}`;
            const originalName = file.name || `image_${Date.now()}.jpg`;
            const wrapper = createPhotoElement(id, processedBlob, originalName);
            fragment.appendChild(wrapper);
            lastAddedElement = wrapper;
        } catch (error) {
            console.error(error);
        }
    }

    if (insertionPoint) {
        insertionPoint.after(fragment);
    } else {
        photoGrid.appendChild(fragment);
    }

    updateNumberingAndSync(); 
    if (lastAddedElement) {
        document.querySelectorAll('.selected-photo').forEach(el => el.classList.remove('selected-photo'));
        lastAddedElement.classList.add('selected-photo');
        lastSelectedWrapper = lastAddedElement;
        lastAddedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        updatePreview(lastAddedElement);
    }
    updateCurrentState();
}

function generateZipWithProgress() { 
    if (isDownloading) return alert('Qu√° tr√¨nh t·∫£i xu·ªëng ƒëang di·ªÖn ra.'); 
    const wrappers = photoGrid.querySelectorAll('.photo-wrapper'); 
    if (wrappers.length === 0) return alert('Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ t·∫£i xu·ªëng.'); 
    isDownloading = true; 
    const zip = new JSZip(); 
    
    wrappers.forEach(wrapper => { 
        const id = wrapper.getAttribute('data-photo-id'); 
        const nameInput = wrapper.querySelector('.name-container input[type="text"]'); 
        if (id && photoDataMap.has(id)) { 
            const { blob } = photoDataMap.get(id); 
            // Blob trong photoDataMap ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi xoay ·∫£nh
            const fullFileName = nameInput.value.trim() || `image_${id}`; 
            const extension = blob.type.split('/')[1] || 'jpg'; 
            const finalZipName = `${fullFileName.replace(/[<>:"/\\|?*]+/g, '_')}.${extension}`; 
            zip.file(finalZipName, blob); 
        } 
    }); 

    const progressBar = document.getElementById('download-progress'); 
    progressBar.style.display = 'block'; 
    progressBar.value = 0; 
    zip.generateAsync({ type: "blob" }, (metadata) => { progressBar.value = metadata.percent; })
    .then((content) => saveAs(content, 'all_photos.zip'))
    .catch(err => { console.error("L·ªói:", err); alert("L·ªói khi t·∫°o file ZIP."); })
    .finally(() => { progressBar.style.display = 'none'; isDownloading = false; }); 
}

// === LOGIC K√âO TH·∫¢ GI·ªÆ TH·ª® T·ª∞ (Quan tr·ªçng) ===
function initializeSortable(isDraggable) {
    if (sortableInstance) sortableInstance.destroy();
    if (photoGrid) {
        sortableInstance = new Sortable(photoGrid, {
            group: 'shared-photos',
            animation: 150,
            ghostClass: 'ghost-class',
            dragClass: 'drag-class',
            draggable: '.photo-wrapper',
            sort: isDraggable,
            onStart: function(evt) {
                // Thu th·∫≠p c√°c item ƒë∆∞·ª£c ch·ªçn theo ƒë√∫ng th·ª© t·ª± DOM hi·ªán t·∫°i
                const allSelected = Array.from(photoGrid.querySelectorAll('.selected-photo'));
                // N·∫øu item ƒëang k√©o kh√¥ng n·∫±m trong nh√≥m selected, th√¨ ch·ªâ k√©o ch√≠nh n√≥
                if (!evt.item.classList.contains('selected-photo')) {
                    draggedItems = [];
                } else {
                    // L·ªçc b·ªè item ch√≠nh ƒëang ƒë∆∞·ª£c Sortable x·ª≠ l√Ω ƒë·ªÉ tr√°nh conflict
                    draggedItems = allSelected.filter(item => item !== evt.item);
                }
                // ·∫®n c√°c item ƒëi theo ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng gom l·∫°i
                draggedItems.forEach(item => item.style.display = 'none');
            },
            onEnd: function(evt) {
                // Hi·ªán l·∫°i c√°c item
                draggedItems.forEach(item => item.style.display = '');
                
                // Logic ch√®n l·∫°i: Ch√®n l·∫ßn l∆∞·ª£t sau item v·ª´a th·∫£ ƒë·ªÉ gi·ªØ th·ª© t·ª±
                let referenceNode = evt.item;
                draggedItems.forEach(item => {
                    // InsertAfter logic
                    referenceNode.parentNode.insertBefore(item, referenceNode.nextSibling);
                    // C·∫≠p nh·∫≠t referenceNode ƒë·ªÉ item ti·∫øp theo n·∫±m sau item n√†y
                    referenceNode = item;
                });
                
                draggedItems = [];
                saveState();
                updateNumberingAndSync();
                updateCurrentState();
            },
        });
    }
}

function reInitializeApp() { 
    photoGrid = document.getElementById('photo-grid-main'); 
    photoGrid.querySelectorAll('.photo-wrapper').forEach(wrapper => { 
        const id = wrapper.getAttribute('data-photo-id'); 
        const img = wrapper.querySelector('.photo-item'); 
        if (id && img && photoDataMap.has(id)) { 
            const data = photoDataMap.get(id); 
            if(data && data.blob) img.src = URL.createObjectURL(data.blob); 
        } 
    }); 
    
    gridToggleBtn.textContent = photoGrid.classList.contains('dense-mode') ? 'Ch·∫ø ƒë·ªô l∆∞·ªõi b√¨nh th∆∞·ªùng' : 'Ch·∫ø ƒë·ªô l∆∞·ªõi x2';
    document.getElementById('lock-toggle').checked = false; 
    initializeSortable(true); 
    const selectedEl = photoGrid.querySelector('.selected-photo'); 
    lastSelectedWrapper = selectedEl || null; 
    updatePreview(lastSelectedWrapper); 
    syncNameListFromInputs(); 
}

// === EVENT LISTENERS FOR PREVIEW ===
// X·ª≠ l√Ω zoom b·∫±ng lƒÉn chu·ªôt
largePreviewContainer.addEventListener('wheel', (e) => {
    if (!largePreviewImg.src || largePreviewImg.style.display === 'none') return;
    e.preventDefault();
    const delta = e.deltaY * -0.001; 
    const newScale = Math.min(Math.max(1, imgScale + delta * 5), 10);
    imgScale = newScale;
    if (imgScale === 1) imgTranslate = {x: 0, y: 0};
    updateTransform();
});

// X·ª≠ l√Ω Pan (Ch·ªâ khi gi·ªØ chu·ªôt tr√°i)
largePreviewContainer.addEventListener('mousedown', (e) => {
    if (imgScale <= 1 || !largePreviewImg.src) return;
    if (e.button !== 0) return; // Ch·ªâ chu·ªôt tr√°i
    isPanning = true;
    startPan = { x: e.clientX - imgTranslate.x, y: e.clientY - imgTranslate.y };
    largePreviewContainer.style.cursor = 'grabbing';
});

document.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    e.preventDefault();
    imgTranslate.x = e.clientX - startPan.x;
    imgTranslate.y = e.clientY - startPan.y;
    updateTransform();
});

document.addEventListener('mouseup', () => {
    if (isPanning) {
        isPanning = false;
        largePreviewContainer.style.cursor = 'grab';
    }
});

// Xoay ·∫£nh
rotateLeftBtn.addEventListener('click', () => rotateCurrentPhoto(-90));
rotateRightBtn.addEventListener('click', () => rotateCurrentPhoto(90));

// === CAPTURE V√ÄO CLIPBOARD ===
captureBtn.addEventListener('click', async () => {
    if (!largePreviewImg.src || largePreviewImg.style.display === 'none') {
        alert("Vui l√≤ng ch·ªçn ·∫£nh ƒë·ªÉ xem tr∆∞·ªõc khi copy.");
        return;
    }

    try {
        const naturalWidth = largePreviewImg.naturalWidth;
        const naturalHeight = largePreviewImg.naturalHeight;
        
        // T√≠nh to√°n v√πng crop
        const rect = largePreviewContainer.getBoundingClientRect();
        const containerW = rect.width;
        const containerH = rect.height;

        let cropWidth = naturalWidth / imgScale;
        let cropHeight = cropWidth * 0.75; // T·ª∑ l·ªá 3:4

        const baseScale = Math.min(containerW / naturalWidth, containerH / naturalHeight);
        const displayedImgW = naturalWidth * baseScale * imgScale;
        const displayedImgH = naturalHeight * baseScale * imgScale;

        const imgLeft = (containerW - displayedImgW) / 2 + imgTranslate.x;
        const imgTop = (containerH - displayedImgH) / 2 + imgTranslate.y;

        const relativeCenterX = ((containerW / 2) - imgLeft) / displayedImgW;
        const relativeCenterY = ((containerH / 2) - imgTop) / displayedImgH;

        const centerX_natural = relativeCenterX * naturalWidth;
        const centerY_natural = relativeCenterY * naturalHeight;

        let sx = centerX_natural - (cropWidth / 2);
        let sy = centerY_natural - (cropHeight / 2);

        if (sx < 0) sx = 0;
        if (sy < 0) sy = 0;
        if (sx + cropWidth > naturalWidth) sx = naturalWidth - cropWidth;
        if (sy + cropHeight > naturalHeight) sy = naturalHeight - cropHeight;
        
        if (cropHeight > naturalHeight) {
            cropHeight = naturalHeight;
            cropWidth = cropHeight / 0.75;
            sx = centerX_natural - (cropWidth / 2);
            if (sx < 0) sx = 0;
        }

        const canvas = document.createElement('canvas');
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        const ctx = canvas.getContext('2d');

        ctx.drawImage(largePreviewImg, sx, sy, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

        canvas.toBlob(blob => {
            if (blob) {
                // GHI V√ÄO CLIPBOARD
                navigator.clipboard.write([
                    new ClipboardItem({
                        [blob.type]: blob
                    })
                ]).then(() => {
                    // Hi·ªáu ·ª©ng th√¥ng b√°o nh·ªè n√∫t b·∫•m
                    const originalText = captureBtn.textContent;
                    captureBtn.textContent = "‚úÖ ƒê√£ copy!";
                    setTimeout(() => captureBtn.textContent = originalText, 1500);
                }).catch(err => {
                    console.error(err);
                    alert("Kh√¥ng th·ªÉ copy v√†o clipboard. H√£y ƒë·∫£m b·∫£o trang web c√≥ quy·ªÅn truy c·∫≠p clipboard.");
                });
            }
        }, 'image/png', 1.0);
    } catch (e) {
        console.error("Capture failed:", e);
        alert("C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω ·∫£nh.");
    }
});


// --- S·ª∞ KI·ªÜN CHUNG ---
photoInput.addEventListener('change', (event) => { processAndDisplayFiles(Array.from(event.target.files)); event.target.value = ''; });
document.addEventListener('paste', (event) => { const files = Array.from(event.clipboardData?.items || []).filter(item => item.kind === 'file' && item.type.startsWith('image/')).map(item => item.getAsFile()); if (files.length > 0) { event.preventDefault(); processAndDisplayFiles(files); } });
pasteZone.addEventListener('dragover', e => { e.preventDefault(); pasteZone.classList.add('drag-over'); });
pasteZone.addEventListener('dragleave', e => { e.preventDefault(); pasteZone.classList.remove('drag-over'); });
pasteZone.addEventListener('drop', e => { e.preventDefault(); pasteZone.classList.remove('drag-over'); processAndDisplayFiles(Array.from(e.dataTransfer.files)); });

clearBtn.addEventListener('click', () => { 
    if (photoGrid.children.length > 0 && confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a t·∫•t c·∫£ ·∫£nh kh√¥ng?')) { 
        saveState(); 
        photoGrid.innerHTML = ''; 
        photoDataMap.forEach(data => URL.revokeObjectURL(data.blob)); 
        photoDataMap.clear(); 
        photoIdCounter = 0; 
        lastSelectedWrapper = null; 
        updateCurrentState(); 
        updatePreview(null); 
        syncNameListFromInputs(); 
    } 
});

assignNamesBtn.addEventListener('click', () => { 
    saveState(); 
    const nameList = nameListTextArea.value.trim().split('\n').filter(Boolean); 
    if(nameList.length === 0) return; 
    const wrappers = Array.from(photoGrid.querySelectorAll('.photo-wrapper')); 
    if (rangeNameToggle.checked) { 
        const start = parseInt(document.getElementById('name-range-start').value, 10); 
        const end = parseInt(document.getElementById('name-range-end').value, 10); 
        let nameIndex = 0; 
        for (let i = start - 1; i < Math.min(end, wrappers.length); i++) { 
            if(nameIndex >= nameList.length) break; 
            const wrapper = wrappers[i]; 
            wrapper.querySelector('.name-container input[type="text"]').value = `${i + 1}. ${nameList[nameIndex].trim()}`;
            nameIndex++; 
        } 
    } else { 
        wrappers.forEach((wrapper, index) => { 
            if (nameList[index]) wrapper.querySelector('.name-container input[type="text"]').value = `${index + 1}. ${nameList[index].trim()}`;
        }); 
    } 
    updateCurrentState(); 
});

rangeNameToggle.addEventListener('change', (e) => { rangeInputsContainer.style.display = e.target.checked ? 'flex' : 'none'; });
downloadAllBtn.addEventListener('click', generateZipWithProgress);
undoBtn.addEventListener('click', restoreStateFromHistory);
lockToggle.addEventListener('change', (e) => { initializeSortable(!e.target.checked); });
document.addEventListener('keydown', (e) => { if (e.ctrlKey && e.key === 'z') { e.preventDefault(); restoreStateFromHistory(); } });

gridToggleBtn.addEventListener('click', () => {
    photoGrid.classList.toggle('dense-mode');
    gridToggleBtn.textContent = photoGrid.classList.contains('dense-mode') ? 'Ch·∫ø ƒë·ªô l∆∞·ªõi b√¨nh th∆∞·ªùng' : 'Ch·∫ø ƒë·ªô l∆∞·ªõi x2';
});

// X·ª≠ l√Ω click ch·ªçn ·∫£nh
mainContentEl.addEventListener('click', (event) => {
    const target = event.target;
    const wrapper = target.closest('.photo-wrapper');
    
    if (wrapper) {
        if (target.classList.contains('delete-btn')) {
            saveState();
            const wasSelected = wrapper.classList.contains('selected-photo');
            if (lastSelectedWrapper === wrapper) lastSelectedWrapper = null;
            wrapper.remove();
            updateNumberingAndSync(); 
            updateCurrentState();
            if (wasSelected) updatePreview(null);
            return;
        }

        if (target.closest('.img-container')) {
            if (!event.ctrlKey && !event.shiftKey) {
                document.querySelectorAll('.selected-photo').forEach(w => w.classList.remove('selected-photo'));
                wrapper.classList.add('selected-photo');
            } 
            else if (event.ctrlKey) wrapper.classList.toggle('selected-photo');
            else if (event.shiftKey && lastSelectedWrapper) {
                const wrappers = Array.from(photoGrid.querySelectorAll('.photo-wrapper'));
                const [start, end] = [wrappers.indexOf(lastSelectedWrapper), wrappers.indexOf(wrapper)].sort((a,b)=>a-b);
                for (let i = start; i <= end; i++) wrappers[i].classList.add('selected-photo');
            }

            lastSelectedWrapper = wrapper.classList.contains('selected-photo') ? wrapper : (photoGrid.querySelector('.selected-photo') || null);
            updatePreview(wrapper.classList.contains('selected-photo') ? wrapper : null);
        }
    }
});

// === ƒê·ªíNG B·ªò INPUT -> TEXTAREA V√Ä SCROLL (REQUIREMENT 3) ===
mainContentEl.addEventListener('input', (event) => {
    const target = event.target;
    
    // N·∫øu ƒëang s·ª≠a t√™n ·ªü input nh·ªè
    if (target.matches('.name-container input[type="text"]')) {
        // C·∫≠p nh·∫≠t danh s√°ch t√™n
        const wrappers = Array.from(photoGrid.querySelectorAll('.photo-wrapper'));
        const index = wrappers.indexOf(target.closest('.photo-wrapper'));
        
        // C·∫≠p nh·∫≠t gi√° tr·ªã v√†o textarea
        const allInputs = photoGrid.querySelectorAll('.name-container input[type="text"]');
        const names = Array.from(allInputs).map(inp => removeLeadingOrderPrefix(inp.value.trim()));
        nameListTextArea.value = names.join('\n');
        
        // T√≠nh nƒÉng cu·ªôn textarea ƒë·∫øn ƒë√∫ng d√≤ng
        if (index >= 0) {
            // T√≠nh to√°n v·ªã tr√≠ d√≤ng. Chi·ªÅu cao d√≤ng (line-height) kho·∫£ng 20px (t√πy font)
            // C√°ch ch√≠nh x√°c nh·∫•t l√† set scrollTop d·ª±a tr√™n t·ª∑ l·ªá
            const lineHeight = 18; // ∆Ø·ªõc l∆∞·ª£ng font monospace 13px line-height 1.5
            const scrollPos = index * lineHeight;
            nameListTextArea.scrollTop = scrollPos;
        }
    }
    
    // L∆∞u state khi d·ª´ng g√µ
    if (target.matches('.name-container input[type="text"]') || target.matches('#name-list')) {
        clearTimeout(target.saveTimeout);
        target.saveTimeout = setTimeout(() => { saveState(); updateCurrentState(); }, 500);
    }
});

// Kh·ªüi t·∫°o ban ƒë·∫ßu
reInitializeApp();
saveState();

</script>
</body>
</html>