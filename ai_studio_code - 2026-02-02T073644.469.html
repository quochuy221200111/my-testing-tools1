<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Studio Pro (Upgraded)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        :root {
            --bg: #101010; --surface: #1e1e1e; --panel: #252525;
            --primary: #00d2ff; --secondary: #7b42f6; --accent: #ff0055; --warning: #ffc107;
            --text: #e0e0e0; --text-muted: #888;
            --border-color: #333;
        }
        * { box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif; background-color: var(--bg); color: var(--text);
            margin: 0; display: flex; flex-direction: column; align-items: center;
            padding: 15px 10px;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 20px;
            width: 100%;
            max-width: 1300px;
        }
        .panel { background: var(--panel); border-radius: 15px; padding: 20px; border: 1px solid var(--border-color); margin-bottom: 20px; }
        .panel-title { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; cursor: pointer; }
        .panel-content { max-height: 1000px; overflow: hidden; transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out; }
        .panel.collapsed .panel-content { max-height: 0; margin-top: -15px !important; }
        .panel-title .toggle-icon { transition: transform 0.3s; }
        .panel.collapsed .toggle-icon { transform: rotate(-90deg); }

        /* Tối ưu không gian: Bỏ tiêu đề, monitor làm phần chính */
        .monitor-screen { background: #000; border-radius: 10px; height: 150px; position: relative; border: 1px solid #444; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        canvas#realtimeWaveform { width: 100%; height: 100%; display: block; position: absolute; top:0; left:0; z-index: 1; }
        .timer-overlay { position: absolute; bottom: 10px; right: 15px; font-family: monospace; color: var(--primary); font-size: 1.5rem; z-index: 10; text-shadow: 0 0 5px #000; }
        
        /* Điều khiển chính: Record/Stop/Pause */
        .main-controls { display: flex; justify-content: center; gap: 20px; margin: 20px 0; }
        .btn-big { width: 70px; height: 70px; border-radius: 50%; border: none; font-size: 1.8rem; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; box-shadow: 0 8px 15px rgba(0,0,0,0.3); }
        #btnRecordStop { background: #ddd; color: #111; }
        #btnRecordStop.recording { background: var(--accent); color: white; animation: pulse 1.5s infinite; }
        #btnRecordStop.recording i.fa-microphone { display: none; }
        #btnRecordStop:not(.recording) i.fa-stop { display: none; }
        #btnPause { background: #444; color: #aaa; }
        #btnPause.paused { background: var(--primary); color: #000; }
        #btnPause:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Thanh trượt có định lượng và nút khóa */
        .slider-group { margin-bottom: 15px; }
        .slider-container { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .slider-label { width: 70px; font-size: 0.8rem; color: #aaa; flex-shrink: 0; }
        input[type=range] { flex-grow: 1; accent-color: var(--primary); -webkit-appearance: none; background: #444; height: 4px; border-radius: 2px; transition: opacity 0.2s; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 15px; height: 15px; background: white; border-radius: 50%; cursor: pointer; }
        input[type=number] { width: 60px; background: #333; border: 1px solid #555; color: var(--text); border-radius: 5px; padding: 4px 8px; font-size: 0.8rem; }
        .sliders-locked input[type=range] { pointer-events: none; opacity: 0.6; }

        /* Nút và Preset */
        .btn-small-icon { background: none; border: 1px solid #555; color: #aaa; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; transition: 0.2s; margin-left: 5px; }
        .btn-small-icon:hover { background: #444; color: white; }
        .preset-controls, .project-controls { display: flex; gap: 10px; align-items: center; margin-bottom: 15px; }
        select { background: #333; color: var(--text); border: 1px solid #555; border-radius: 5px; padding: 5px 10px; flex-grow: 1; }

        /* Giao diện dự án */
        .project-header {
            padding: 15px; background: var(--surface); border-radius: 10px; margin-bottom: 20px;
        }

        /* Thư viện & Lời bài hát */
        #playlist, #lyrics-playlist { max-height: 200px; overflow-y: auto; padding-right: 5px; }
        .record-item, .lyric-item { background: #2a2a2a; padding: 10px 15px; border-radius: 8px; margin-bottom: 10px; display: flex; align-items: center; gap: 15px; border: 1px solid #444; transition: 0.2s; }
        .record-item.selected, .lyric-item.selected { background-color: #303f5a; border-color: var(--primary); }
        .record-item-info, .lyric-item { flex-grow: 1; cursor: pointer; }
        
        /* Bộ nhớ */
        #storage-warning { display: none; background-color: var(--warning); color: #000; padding: 10px; border-radius: 8px; margin-bottom: 15px; font-weight: bold; font-size: 0.9rem; }
        #storageStatus { font-size: 0.8rem; color: var(--text-muted); text-align: right; margin-top: 10px; }

        /* Modal */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; align-items: center; justify-content: center; padding: 15px; }
        .modal-content { background: var(--surface); padding: 30px; border-radius: 15px; width: 100%; max-width: 800px; text-align: center; }
        .trim-canvas-container { width: 100%; height: 150px; background: #000; position: relative; margin: 20px 0; border: 1px solid #444; }
        #trimCanvas { position: absolute; top:0; left:0; width:100%; height:100%;}
        .form-group { margin-bottom: 15px; text-align: left; }
        .form-group label { display: block; margin-bottom: 5px; color: var(--text-muted); }
        .form-group input, .form-group select { width: 100%; padding: 8px; background: #333; border: 1px solid #555; color: var(--text); border-radius: 5px; }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.4); } 70% { box-shadow: 0 0 0 20px rgba(255, 0, 85, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); } }
        /* Responsive cho di động */
        @media (max-width: 900px) { 
            .main-container { grid-template-columns: 1fr; } 
            .panel { padding: 15px; }
        }
    </style>
</head>
<body>

<div class="main-container">
    <!-- CỘT TRÁI: ĐIỀU KHIỂN & HÌNH ẢNH -->
    <div>
        <div class="panel">
            <div class="monitor-screen">
                <canvas id="realtimeWaveform"></canvas>
                <div id="timer" class="timer-overlay">00:00</div>
            </div>
        </div>

        <div class="main-controls">
            <button id="btnRecordStop" class="btn-big" title="Thu âm / Dừng">
                <i class="fas fa-microphone"></i>
                <i class="fas fa-stop"></i>
            </button>
            <button id="btnPause" class="btn-big" title="Tạm dừng" disabled><i class="fas fa-pause"></i></button>
        </div>

        <div class="panel fx-panel">
            <div class="panel-title">
                <span>Hiệu ứng & EQ</span>
                <button id="toggleSliderEdit" class="btn-small-icon" title="Mở/Khóa chỉnh sửa"><i class="fas fa-lock"></i></button>
            </div>
            <div id="slidersContainer" class="panel-content sliders-locked">
                <div class="preset-controls">
                    <select id="presetSelector"><option value="">Chọn Preset</option></select>
                    <button id="btnSavePreset" class="btn-small-icon" title="Lưu Preset mới"><i class="fas fa-save"></i></button>
                </div>
                <div class="slider-group">
                    <div class="slider-container"><span class="slider-label">Low</span><input type="range" class="fx-slider" data-fx="eq.low" min="-12" max="12" value="0" step="1"><input type="number" class="fx-number" data-fx="eq.low" min="-12" max="12" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Low-Mid</span><input type="range" class="fx-slider" data-fx="eq.lowMid" min="-12" max="12" value="0" step="1"><input type="number" class="fx-number" data-fx="eq.lowMid" min="-12" max="12" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Mid</span><input type="range" class="fx-slider" data-fx="eq.mid" min="-12" max="12" value="0" step="1"><input type="number" class="fx-number" data-fx="eq.mid" min="-12" max="12" value="0"></div>
                    <div class="slider-container"><span class="slider-label">Hi-Mid</span><input type="range" class="fx-slider" data-fx="eq.highMid" min="-12" max="12" value="0" step="1"><input type="number" class="fx-number" data-fx="eq.highMid" min="-12" max="12" value="0"></div>
                    <div class="slider-container"><span class="slider-label">High</span><input type="range" class="fx-slider" data-fx="eq.high" min="-12" max="12" value="0" step="1"><input type="number" class="fx-number" data-fx="eq.high" min="-12" max="12" value="0"></div>
                </div>
                 <div class="slider-group">
                    <div class="slider-container"><span class="slider-label">Reverb</span><input type="range" class="fx-slider" data-fx="reverb.mix" min="0" max="1" value="0" step="0.01"><input type="number" class="fx-number" data-fx="reverb.mix" min="0" max="1" value="0" step="0.01"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- CỘT PHẢI: DỰ ÁN, LYRICS & THƯ VIỆN -->
    <div>
        <div class="project-header">
            <div class="project-controls">
                <select id="projectSelector"><option value="all">Tất cả dự án</option></select>
                <button id="btnNewProject" class="btn-small-icon" title="Tạo dự án mới"><i class="fas fa-plus"></i></button>
            </div>
        </div>

        <div class="panel lyrics-panel">
            <div class="panel-title"><span>Lời bài hát</span><i class="fas fa-music toggle-icon"></i></div>
            <div class="panel-content">
                <div id="lyrics-playlist"></div>
                <div style="display: flex; justify-content: flex-end; margin: 10px 0;">
                    <button id="btnSaveLyrics" class="btn-small-icon" title="Lưu lời mới"><i class="fas fa-save"></i></button>
                    <button id="btnDeleteLyrics" class="btn-small-icon" title="Xóa lời đang chọn"><i class="fas fa-trash-alt"></i></button>
                </div>
                <textarea id="lyricsInput" placeholder="Dán lời bài hát vào đây..." style="width: 100%; height: 150px; background: #1a1a1a; border: 1px solid var(--border-color); color: var(--text); padding: 10px; border-radius: 8px;"></textarea>
            </div>
        </div>

        <div class="panel playlist-panel">
            <div class="panel-title"><span>Thư viện</span><i class="fas fa-list-ul toggle-icon"></i></div>
            <div class="panel-content">
                <div id="storage-warning"></div>
                <div id="playlist"></div>
                <div id="storageStatus"></div>
            </div>
        </div>
    </div>
</div>

<!-- MODAL LƯU BẢN THU -->
<div id="trimModal" class="modal">
    <div class="modal-content">
        <h2>Chỉnh sửa & Lưu bản thu</h2>
        <div class="trim-canvas-container"><canvas id="trimCanvas"></canvas></div>
        
        <div class="form-group">
            <label for="recordingNameInput">Tên tùy biến:</label>
            <input type="text" id="recordingNameInput" placeholder="VD: Verse 1, Demo...">
        </div>
        <div class="form-group">
            <label for="saveToProjectSelector">Lưu vào dự án:</label>
            <select id="saveToProjectSelector"></select>
        </div>

        <div style="margin-top:20px;">
            <button id="btnCancelTrim" class="btn-cancel" style="background: #444; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 0 5px;">Hủy bỏ</button>
            <button id="btnSaveTrim" class="btn-save" style="background: var(--primary); color: #000; border: none; padding: 10px 30px; border-radius: 5px; font-weight: bold; cursor: pointer; margin: 0 5px;"><i class="fas fa-save"></i> Lưu</button>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- GLOBAL STATE & DOM ELEMENTS ---
    let db;
    let audioCtx, micStream, micSource, workletNode, analyser;
    let isRecording = false;
    let isPaused = false;
    let audioBuffer = [];
    let fullAudioData;
    let sampleRate = 48000;
    let timerInterval, startTime, pausedTime = 0;
    
    // Realtime waveform drawing state
    let waveformPoints = [];
    let lastWaveformX = 0;

    let fxState = {
        eq: { low: 0, lowMid: 0, mid: 0, highMid: 0, high: 0 },
        reverb: { mix: 0 }
    };

    // --- INITIALIZATION ---
    initDB();
    setupEventListeners();
    updateUIFromState();
    checkStorageQuota(); // Initial check on load
    
    // --- DATABASE (INDEXEDDB) ---
    function initDB() {
        const req = indexedDB.open("VocalStudioDB_V3", 1);
        req.onupgradeneeded = e => {
            db = e.target.result;
            if (!db.objectStoreNames.contains('projects')) {
                db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
            }
            if (!db.objectStoreNames.contains('presets')) {
                db.createObjectStore('presets', { keyPath: 'id', autoIncrement: true });
            }
            if (!db.objectStoreNames.contains('recs')) {
                const recStore = db.createObjectStore('recs', { keyPath: 'id', autoIncrement: true });
                recStore.createIndex('projectId', 'projectId', { unique: false });
            }
            if (!db.objectStoreNames.contains('lyrics')) {
                const lyricStore = db.createObjectStore('lyrics', { keyPath: 'id', autoIncrement: true });
                lyricStore.createIndex('projectId', 'projectId', { unique: false });
            }
        };
        req.onsuccess = e => {
            db = e.target.result;
            loadProjects();
            loadPresets();
            loadFilteredContent();
            requestPersistentStorage(); // Request persistent storage on successful DB connection
        };
        req.onerror = e => console.error("DB Error:", e.target.errorCode);
    }
    
    // --- STORAGE MANAGEMENT (PERSISTENCE & QUOTA) ---
    async function requestPersistentStorage() {
        if (navigator.storage && navigator.storage.persist) {
            if (await navigator.storage.persisted()) {
                console.log("Storage is already persistent.");
                return;
            }
            const isPersisted = await navigator.storage.persist();
            console.log(`Storage persistence request: ${isPersisted ? 'Success' : 'Failure'}`);
        }
    }

    async function checkStorageQuota(showAlerts = true) {
        if (!navigator.storage || !navigator.storage.estimate) return true; // Assume OK if API not supported

        const estimate = await navigator.storage.estimate();
        const usage = estimate.usage;
        const quota = estimate.quota;
        const percentageUsed = (usage / quota) * 100;
        
        const usageMB = (usage / 1024 / 1024).toFixed(1);
        const quotaMB = (quota / 1024 / 1024).toFixed(1);

        // Update UI
        const statusEl = document.getElementById('storageStatus');
        statusEl.textContent = `Bộ nhớ đã dùng: ${usageMB} MB / ${quotaMB} MB (${percentageUsed.toFixed(1)}%)`;

        const warningEl = document.getElementById('storage-warning');
        if (percentageUsed > 80 && showAlerts) {
            warningEl.style.display = 'block';
            warningEl.textContent = `Cảnh báo: Bộ nhớ đã sử dụng ${percentageUsed.toFixed(0)}%. Hãy tải về các bản ghi cũ để giải phóng dung lượng.`;
        } else {
            warningEl.style.display = 'none';
        }

        if (percentageUsed > 98 && showAlerts) {
            alert(`LỖI: Bộ nhớ gần đầy (${percentageUsed.toFixed(0)}%)! Không thể lưu bản ghi mới. Vui lòng xóa các bản ghi cũ.`);
            return false; // Not enough space
        }
        return true; // Enough space
    }

    // --- EVENT LISTENERS ---
    function setupEventListeners() {
        document.getElementById('btnRecordStop').onclick = toggleRecording;
        document.getElementById('btnPause').onclick = togglePause;
        document.getElementById('toggleSliderEdit').onclick = toggleSliderLock;
        
        document.querySelectorAll('.fx-slider, .fx-number').forEach(input => {
            input.oninput = handleSliderInput;
        });

        document.getElementById('btnSavePreset').onclick = savePreset;
        document.getElementById('presetSelector').onchange = applySelectedPreset;

        document.getElementById('btnNewProject').onclick = addNewProject;
        document.getElementById('projectSelector').onchange = loadFilteredContent;

        document.getElementById('btnSaveLyrics').onclick = saveLyrics;
        document.getElementById('btnDeleteLyrics').onclick = deleteCurrentLyrics;
        document.getElementById('lyrics-playlist').addEventListener('click', (e) => {
            const item = e.target.closest('.lyric-item');
            if (item) loadSelectedLyrics(parseInt(item.dataset.id));
        });

        document.getElementById('btnCancelTrim').onclick = () => document.getElementById('trimModal').style.display = 'none';
        document.getElementById('btnSaveTrim').onclick = saveTrimmedAudio;
    }

    // --- RECORDING CONTROLS ---
    async function toggleRecording() {
        if (isRecording) {
            stopRecording();
        } else {
            // Check storage before starting
            const canRecord = await checkStorageQuota();
            if (!canRecord) return;
            startRecording();
        }
    }
    
    async function startRecording() {
        if (isRecording) return;
        await initAudio();
        if(!audioCtx) return;

        isRecording = true;
        isPaused = false;
        audioBuffer = [];
        waveformPoints = [];
        lastWaveformX = 0;
        clearRealtimeWaveform();

        audioCtx.resume();
        
        document.getElementById('btnRecordStop').classList.add('recording');
        document.getElementById('btnPause').disabled = false;
        
        startTime = Date.now();
        pausedTime = 0;
        timerInterval = setInterval(updateTimer, 1000);
        
        drawRealtimeWaveform();
    }

    function stopRecording() {
        if (!isRecording) return;
        isRecording = false;
        isPaused = false;
        
        clearInterval(timerInterval);
        document.getElementById('btnRecordStop').classList.remove('recording');
        document.getElementById('btnPause').classList.remove('paused');
        document.getElementById('btnPause').disabled = true;

        micStream?.getTracks().forEach(track => track.stop());
        micStream = null;
        audioCtx?.close().then(() => { audioCtx = null; });
        
        if (audioBuffer.length > 0) {
            openTrimmer();
        }
    }
    
    function togglePause() {
        if (!isRecording) return;
        isPaused = !isPaused;
        if (isPaused) {
            audioCtx.suspend();
            pausedTime = Date.now();
            document.getElementById('btnPause').classList.add('paused');
        } else {
            audioCtx.resume();
            startTime += (Date.now() - pausedTime); // Adjust start time to account for pause
            document.getElementById('btnPause').classList.remove('paused');
        }
    }

    function updateTimer() {
        if (!isRecording || isPaused) return;
        const diff = Math.floor((Date.now() - startTime) / 1000);
        const m = Math.floor(diff/60).toString().padStart(2,'0');
        const s = (diff%60).toString().padStart(2,'0');
        document.getElementById('timer').innerText = `${m}:${s}`;
    }

    // --- AUDIO ENGINE ---
    async function initAudio() {
        try {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
            sampleRate = audioCtx.sampleRate;
    
            micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, channelCount: 1 }});
            micSource = audioCtx.createMediaStreamSource(micStream);
    
            const workletCode = `class P extends AudioWorkletProcessor{process(i){this.port.postMessage(i[0][0]);return true}}registerProcessor('r',P)`;
            const blob = new Blob([workletCode], { type: 'application/javascript' });
            await audioCtx.audioWorklet.addModule(URL.createObjectURL(blob));
    
            workletNode = new AudioWorkletNode(audioCtx, 'r');
            workletNode.port.onmessage = (e) => {
                if (isRecording && !isPaused && e.data) {
                    const chunk = new Float32Array(e.data);
                    audioBuffer.push(chunk);
                    
                    // Process for realtime waveform
                    let max = 0.0;
                    for (let i = 0; i < chunk.length; i++) {
                        if (Math.abs(chunk[i]) > max) max = Math.abs(chunk[i]);
                    }
                    waveformPoints.push(max);
                }
            };
    
            // Build FX chain here if needed
            micSource.connect(workletNode);
            // Don't connect to destination to avoid feedback
        } catch (err) {
            alert("Không thể truy cập micro. Vui lòng cấp quyền và thử lại.");
            console.error("Audio Init Error:", err);
            audioCtx = null;
        }
    }
    
    // --- REALTIME VISUALIZATION ---
    function clearRealtimeWaveform() {
        const canvas = document.getElementById('realtimeWaveform');
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawRealtimeWaveform() {
        if (!isRecording) return;
        
        const canvas = document.getElementById('realtimeWaveform');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const h2 = h / 2;
        
        ctx.strokeStyle = 'var(--primary)';
        ctx.lineWidth = 2;

        for (let i = lastWaveformX; i < waveformPoints.length; i++) {
            const x = (i / (sampleRate / 128 * 5)) * w; // Adjust scaling for visibility
            if (x > w) continue;
            const val = waveformPoints[i] * h2;
            ctx.beginPath();
            ctx.moveTo(x, h2 - val);
            ctx.lineTo(x, h2 + val);
            ctx.stroke();
        }
        lastWaveformX = waveformPoints.length;

        requestAnimationFrame(drawRealtimeWaveform);
    }

    // --- SLIDER & PRESET CONTROLS ---
    function toggleSliderLock() {
        const container = document.getElementById('slidersContainer');
        const icon = document.querySelector('#toggleSliderEdit i');
        container.classList.toggle('sliders-locked');
        if (container.classList.contains('sliders-locked')) {
            icon.classList.replace('fa-lock-open', 'fa-lock');
        } else {
            icon.classList.replace('fa-lock', 'fa-lock-open');
        }
    }

    function handleSliderInput(e) {
        const path = e.target.dataset.fx.split('.');
        const value = parseFloat(e.target.value);
        
        let target = fxState;
        for (let i = 0; i < path.length - 1; i++) {
            target = target[path[i]];
        }
        target[path[path.length - 1]] = value;
        
        updateUIFromState();
        // applyFxSettings(); // Function to apply FX to audio context if live
    }

    function updateUIFromState() {
        document.querySelectorAll('.fx-slider, .fx-number').forEach(input => {
            const path = input.dataset.fx.split('.');
            let value = fxState;
            path.forEach(p => value = value[p]);
            input.value = value;
        });
    }

    function savePreset() {
        const name = prompt("Đặt tên cho preset này:");
        if (!name) return;
        const preset = { name, state: JSON.parse(JSON.stringify(fxState)) };
        const tx = db.transaction('presets', 'readwrite');
        tx.objectStore('presets').add(preset);
        tx.oncomplete = loadPresets;
    }

    function loadPresets() {
        const selector = document.getElementById('presetSelector');
        selector.innerHTML = '<option value="">Chọn Preset</option>';
        db.transaction('presets').objectStore('presets').openCursor().onsuccess = e => {
            const cursor = e.target.result;
            if (cursor) {
                const opt = document.createElement('option');
                opt.value = cursor.value.id;
                opt.textContent = cursor.value.name;
                selector.appendChild(opt);
                cursor.continue();
            }
        };
    }
    
    function applySelectedPreset(e) {
        const id = parseInt(e.target.value);
        if (!id) return;
        db.transaction('presets').objectStore('presets').get(id).onsuccess = e => {
            if (e.target.result) {
                fxState = e.target.result.state;
                updateUIFromState();
                // applyFxSettings();
            }
        };
    }
    
    // --- PROJECT MANAGEMENT ---
    function addNewProject() {
        const name = prompt("Nhập tên dự án mới:");
        if (!name) return;
        const tx = db.transaction('projects', 'readwrite');
        tx.objectStore('projects').add({ name });
        tx.oncomplete = loadProjects;
    }

    function loadProjects() {
        const mainSelector = document.getElementById('projectSelector');
        const saveSelector = document.getElementById('saveToProjectSelector');
        mainSelector.innerHTML = '<option value="all">Tất cả dự án</option><option value="none">Không thuộc dự án</option>';
        saveSelector.innerHTML = '<option value="none">Không thuộc dự án</option>';
        
        db.transaction('projects').objectStore('projects').openCursor().onsuccess = e => {
            const cursor = e.target.result;
            if (cursor) {
                const opt = document.createElement('option');
                opt.value = cursor.value.id;
                opt.textContent = cursor.value.name;
                mainSelector.appendChild(opt.cloneNode(true));
                saveSelector.appendChild(opt);
                cursor.continue();
            }
        };
    }
    
    function loadFilteredContent() {
        loadPlaylist();
        loadLyricsLibrary();
    }
    
    // --- LYRICS ---
    function saveLyrics() {
        const content = document.getElementById('lyricsInput').value.trim();
        if (!content) return alert("Nội dung không được để trống.");
        const name = prompt("Đặt tên cho lời bài hát:", `Lyrics ${new Date().toLocaleDateString()}`);
        if (!name) return;

        const projectId = document.getElementById('projectSelector').value;
        const lyric = { name, content, projectId: projectId === 'all' || projectId === 'none' ? null : parseInt(projectId) };
        
        const tx = db.transaction('lyrics', 'readwrite');
        tx.objectStore('lyrics').add(lyric);
        tx.oncomplete = loadLyricsLibrary;
    }
    
    function loadLyricsLibrary() {
        const container = document.getElementById('lyrics-playlist');
        container.innerHTML = '';
        const currentProjectId = document.getElementById('projectSelector').value;
        
        const store = db.transaction('lyrics').objectStore('lyrics');
        const index = store.index('projectId');
        
        let request;
        if (currentProjectId === 'all') request = store.openCursor(null, 'prev');
        else if (currentProjectId === 'none') request = index.openCursor(IDBKeyRange.only(null), 'prev');
        else request = index.openCursor(IDBKeyRange.only(parseInt(currentProjectId)), 'prev');
        
        request.onsuccess = e => {
            const cursor = e.target.result;
            if (cursor) {
                const item = document.createElement('div');
                item.className = 'lyric-item';
                item.dataset.id = cursor.value.id;
                item.textContent = cursor.value.name;
                container.appendChild(item);
                cursor.continue();
            }
        };
    }
    
    function loadSelectedLyrics(id) {
        document.querySelectorAll('#lyrics-playlist .lyric-item').forEach(item => {
            item.classList.toggle('selected', parseInt(item.dataset.id) === id);
        });
        db.transaction('lyrics').objectStore('lyrics').get(id).onsuccess = e => {
            if(e.target.result) document.getElementById('lyricsInput').value = e.target.result.content;
        };
    }
    
    function deleteCurrentLyrics() {
        const selected = document.querySelector('#lyrics-playlist .lyric-item.selected');
        if (!selected) return alert("Vui lòng chọn lời để xóa.");
        const id = parseInt(selected.dataset.id);
        if (confirm("Bạn chắc chắn muốn xóa?")) {
            const tx = db.transaction('lyrics', 'readwrite');
            tx.objectStore('lyrics').delete(id);
            tx.oncomplete = () => {
                document.getElementById('lyricsInput').value = '';
                loadLyricsLibrary();
            };
        }
    }

    // --- TRIMMER & SAVING ---
    function openTrimmer() {
        const modal = document.getElementById('trimModal');
        modal.style.display = 'flex';
        
        const length = audioBuffer.reduce((sum, chunk) => sum + chunk.length, 0);
        fullAudioData = new Float32Array(length);
        let offset = 0;
        audioBuffer.forEach(chunk => {
            fullAudioData.set(chunk, offset);
            offset += chunk.length;
        });

        drawTrimWaveform(fullAudioData, sampleRate, 'trimCanvas');
    }
    
    async function saveTrimmedAudio() {
        const canSave = await checkStorageQuota();
        if (!canSave) return;
        
        const customName = document.getElementById('recordingNameInput').value.trim();
        if (!customName) return alert("Vui lòng nhập tên tùy biến.");

        const d = new Date();
        const dateString = d.getFullYear().toString().slice(-2) + (d.getMonth() + 1).toString().padStart(2, '0') + d.getDate().toString().padStart(2, '0');
        const recordingName = `${dateString}_${customName}`;
        
        const projectId = document.getElementById('saveToProjectSelector').value;

        const wavBlob = encodeWAV(fullAudioData, sampleRate);
        const record = {
            name: recordingName,
            blob: wavBlob,
            date: new Date(),
            projectId: projectId === 'none' ? null : parseInt(projectId)
        };

        const tx = db.transaction(['recs'], 'readwrite');
        tx.objectStore('recs').add(record);
        tx.oncomplete = () => {
            document.getElementById('trimModal').style.display = 'none';
            document.getElementById('recordingNameInput').value = '';
            loadPlaylist();
            checkStorageQuota(false); // Update quota display without alert
        };
    }

    function drawTrimWaveform(audioData, sampleRate, canvasId) {
        const cvs = document.getElementById(canvasId);
        const ctx = cvs.getContext('2d');
        const w = cvs.width = cvs.clientWidth;
        const h = cvs.height = cvs.clientHeight;
        ctx.clearRect(0,0,w,h);

        const step = Math.ceil(audioData.length / w);
        const amp = h / 2;
        ctx.strokeStyle = 'var(--primary)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<w; i++){
            let min = 1.0, max = -1.0;
            for (let j=0; j<step; j++) {
                const val = audioData[(i * step) + j] || 0;
                if (val < min) min = val; if (val > max) max = val;
            }
            ctx.moveTo(i, amp + min * amp); ctx.lineTo(i, amp + max * amp);
        }
        ctx.stroke();
    }

    function encodeWAV(samples, sampleRate) {
        // Standard WAV encoding logic...
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        const write = (o,s) => { for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); };
        write(0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true);
        write(8, 'WAVE'); write(12, 'fmt '); view.setUint32(16, 16, true);
        view.setUint16(20, 1, true); view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 4, true);
        view.setUint16(32, 4, true); view.setUint16(34, 16, true);
        write(36, 'data'); view.setUint32(40, samples.length * 2, true);
        for (let i = 0; i < samples.length; i++) {
            let s = Math.max(-1, Math.min(1, samples[i]));
            view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
        return new Blob([view], { type: 'audio/wav' });
    }

    // --- PLAYLIST ---
    function loadPlaylist() {
        const list = document.getElementById('playlist');
        list.innerHTML = '';
        const currentProjectId = document.getElementById('projectSelector').value;
        
        const store = db.transaction('recs').objectStore('recs');
        const index = store.index('projectId');
        
        let request;
        if (currentProjectId === 'all') request = store.openCursor(null, 'prev');
        else if (currentProjectId === 'none') request = index.openCursor(IDBKeyRange.only(null), 'prev');
        else request = index.openCursor(IDBKeyRange.only(parseInt(currentProjectId)), 'prev');
        
        request.onsuccess = e => {
            const cursor = e.target.result;
            if (cursor) {
                const url = URL.createObjectURL(cursor.value.blob);
                const div = document.createElement('div');
                div.className = 'record-item';
                div.dataset.id = cursor.value.id;
                div.innerHTML = `
                    <div class="record-item-info">
                        <div style="font-weight:bold">${cursor.value.name}</div>
                        <div style="font-size:0.8rem; color:#888">${cursor.value.date.toLocaleString('vi-VN')}</div>
                    </div>
                    <audio controls src="${url}" style="height:35px;"></audio>
                    <a href="${url}" download="${cursor.value.name}.wav" class="btn-small-icon" title="Tải xuống"><i class="fas fa-download"></i></a>
                    <button class="btn-small-icon btn-delete-rec" data-id="${cursor.value.id}" title="Xóa"><i class="fas fa-trash-alt"></i></button>
                `;
                list.appendChild(div);
                cursor.continue();
            }
        };
    }
    
    document.getElementById('playlist').addEventListener('click', e => {
        if (e.target.closest('.btn-delete-rec')) {
            const btn = e.target.closest('.btn-delete-rec');
            const id = parseInt(btn.dataset.id);
            if (confirm("Xóa bản ghi này?")) {
                const tx = db.transaction('recs', 'readwrite');
                tx.objectStore('recs').delete(id);
                tx.oncomplete = loadPlaylist;
            }
        }
    });
});
</script>

</body>
</html>